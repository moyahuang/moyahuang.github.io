[{"content":"第一章 绪论 1.1 研究背景和意义 Why blockchain?\n参考 Wang-WiMob19-ADAC\n1.2 国内外相关研究现状 1.3 论文主要工作 1.4 论文结构安排 第二章 预备知识 2.1 区块链 2.2 智能合约 2.3 访问控制模型 基于属性的访问控制（ABAC，attribute-based access control），\nACL和RBAC在某种程度上是ABAC的特例，前者基于身份信息（主体）的属性，后者基于角色（例如，管理员，用户）的属性。ABAC与其他模型的主要区别在于基于众多属性（包括主体、客体、环境）进行评估的复杂决策能力。尽管基于ACL和RBAC实现ABAC的目标（todo）也不是不可能，但是达到这样的抽象程度非常困难且昂贵。另一个问题在于进行更新时，要更改的地方太多了。\nXACML（extensible access control markup language）是ABAC的一种实现标准。XACML的基本元素包括规则(（rule）,策略（policies）,环境（conditions)，算法（algos），属性（主体、客体、操作、环境），职责（obligations），以及建议（advice）。参考框架的功能包括策略决策点(policy decision points, PDPs)，策略执行点(policy enforcement points)，策略管理点(policy administration points)，以及策略信息点(policy information points)。\nXACML模型:\r\r ABAC的另一种实现标准是next generation access control （ANSI499）\n大体来说，ABAC避免将访问权限事前直接赋予某一主体，或者其角色、其组别，而是基于主体、客体、环境及其相关访问策略，由ABAC引擎进行决策。因此，访问策略的创建和管理不会影响海量的主客体。主客体的创建也无需与策略先关联。\nIBAC/ACLs(identity-based access control, access control lists)\nACL用例:\r\r RBAC\n缺点：role explosion\nvideo explanation\n参考文献：\n ABAC - 基于属性的访问控制 - 复杂场景下访问控制解决之道(这篇博客以及这篇博客的参考资料非常重要) [Wang-WiMob19-ADAC](Wang, Peng, Yanlin Yue, Wen Sun, and Jiajia Liu. \u0026ldquo;An Attribute-Based Distributed Access Control for Blockchain-enabled IoT.\u0026rdquo; In 2019 International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob), pp. 1-6. IEEE, 2019.)  2.4 本章小结 ","description":"","id":0,"section":"posts","tags":["学术"],"title":"毕业论文草稿","uri":"https://moyahuang.github.io/zh/posts/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E8%8D%89%E7%A8%BF/"},{"content":"\r\rAccessControl.sol\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401  pragma solidity \u0026gt;=0.4.22 \u0026lt;0.7.0; pragma experimental ABIEncoderV2; contract AccessControl { address public manager; Reputation public rc; Management public mc; event ReturnAccessResult( address indexed _from, bool _result, string msg, uint256 _time ); struct attriValue { bool isValued; string value; } struct PolicyItem { //for one (resource, action) pair;  string attrOwner; //attribute of this policyItem belong to, subject or resources  string attrName; //attribute name  string operator; //Conditions operator that policyItem used  string attrValue; //Conditions that policyItem should meet  } struct Environment { uint256 minInterval; //minimum allowable interval (in seconds) between two successive requests  uint256 threshold; //threshold on NoFR, above which a misbehavior is suspected  } Environment public evAttr = Environment(100, 2); struct BehaviorItem { uint256 ToLR; //Time of Last Request  uint256 NoFR; //Number of frequent Requests in a short period of time  } //mapping subjcetAddress =\u0026gt; BehaviorCriteria for behavior check  mapping(address =\u0026gt; BehaviorItem) internal behaviors; //mapping (resource, attributeName) =\u0026gt; attributeValue for define and search resource attribute  mapping(string =\u0026gt; mapping(string =\u0026gt; attriValue)) internal resources; //mapping (resource, action) =\u0026gt;PolicyCriteria for policy check  mapping(string =\u0026gt; mapping(string =\u0026gt; PolicyItem[])) internal policies; /** * @dev Set contract deployer as manager, set management and reputation contract address */ constructor(address _mc, address _rc, address _manager) public { manager = _manager; mc = Management(_mc); rc = Reputation(_rc); } /* @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption */ function stringCompare(string memory a, string memory b) internal pure returns (bool) { bytes memory _a = bytes(a); bytes memory _b = bytes(b); if (_a.length != _b.length) { return false; }else{ if (_a.length == 1) { return _a[0] == _b[0]; }else{ return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)); } } } function updateEnviroment(uint256 _minInterval, uint256 _threshold) public { require( msg.sender == manager, \u0026#34;updateEnviroment error: Only acc manager can update environment value!\u0026#34; ); evAttr.minInterval = _minInterval; evAttr.threshold = _threshold; } /* @dev updateSCAddr update management contract or reputation contract address */ function updateSCAddr(string memory scType, address _scAddress) public { require( msg.sender == manager, \u0026#34;updateSCAddr error: Only acc manager can update mc or rc address!\u0026#34; ); require( stringCompare(scType, \u0026#34;mc\u0026#34;) || stringCompare(scType, \u0026#34;rc\u0026#34;), \u0026#34;updateSCAddr error: Updatable contract type can only be rc or mc!\u0026#34; ); if (stringCompare(scType, \u0026#34;mc\u0026#34;)) { mc = Management(_scAddress); }else{ rc = Reputation(_scAddress); } } /* @dev updateManager update device manager, after that only new manager can operate this access control contract */ function updateManager(address _manager) public { require( msg.sender == manager, \u0026#34;updateManager error: Only management contract can update manager address!\u0026#34; ); manager = _manager; rc.reputationCompute(msg.sender, false, 2, \u0026#34;device manager update\u0026#34;, now); } /* @dev addResourceAttr add resource attribute */ function addResourceAttr( string memory _resource, string memory _attrName, string memory _attrValue ) public { require(msg.sender == manager, \u0026#34;addResourceAttr error: Caller is not manager!\u0026#34;); require( !resources[_resource][_attrName].isValued, \u0026#34;addResourceAttr error: Resource attribute had been setted, pleased call resourceAttrUpdate!\u0026#34; ); resources[_resource][_attrName].value = _attrValue; resources[_resource][_attrName].isValued = true; rc.reputationCompute(msg.sender, false, 1, \u0026#34;Resource attribute add\u0026#34;, now); } /* @dev updateResourceAttr update resource attribute */ function updateResourceAttr( string memory _resource, string memory _attrName, string memory _attrValue ) public { require(msg.sender == manager, \u0026#34;updateResourceAttr error: Caller is not manager!\u0026#34;); require( resources[_resource][_attrName].isValued, \u0026#34;updateResourceAttr error: Resource attribute not exist, pleased first call addResourceAttr!\u0026#34; ); resources[_resource][_attrName].value = _attrValue; rc.reputationCompute(msg.sender, false, 2, \u0026#34;Resource attribute update\u0026#34;, now); } /* @dev getResourceAttr get resource attribute */ function getResourceAttr(string memory _resource, string memory _attrName) public view returns (string memory _attrValue) { require( resources[_resource][_attrName].isValued, \u0026#34;getResourceAttr error: Resource attribute not exist!\u0026#34; ); _attrValue = resources[_resource][_attrName].value; } /* @dev deleteResourceAttr delete the resource attribute */ function deleteResourceAttr( string memory _resource, string memory _attrName ) public { require(msg.sender == manager, \u0026#34;deleteResourceAttr error: Caller is not manager!\u0026#34;); require( resources[_resource][_attrName].isValued, \u0026#34;deleteResourceAttr error: Resource attribute not exist, don\u0026#39;t need delete!\u0026#34; ); delete resources[_resource][_attrName]; rc.reputationCompute(msg.sender, false, 3, \u0026#34;Resource attribute delete\u0026#34;, now); } /* @dev addPolicy add a policy @notice We can\u0026#39;t judge whether the added policy is unique, so there are security risks here */ function addPolicy( string memory _resource, string memory _action, string memory _attrOwner, string memory _attrName, string memory _operator, string memory _attrValue ) public { require(msg.sender == manager, \u0026#34;addPolicy error: Caller is not manager!\u0026#34;); policies[_resource][_action].push( PolicyItem(_attrOwner, _attrName, _operator, _attrValue) ); rc.reputationCompute(msg.sender, false, 1, \u0026#34;policy add\u0026#34;, now); } /* @dev getPolicy get the policy associate with specified resource and action */ function getPolicy( string memory _resource, string memory _action ) public view returns (PolicyItem[] memory) { require(policies[_resource][_action].length != 0, \u0026#34;getPolicy error: There is no policy for this resource and action at this time!\u0026#34;); PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length); for (uint256 i = 0; i \u0026lt; policies[_resource][_action].length; i++) { result[i] = PolicyItem( policies[_resource][_action][i].attrOwner, policies[_resource][_action][i].attrName, policies[_resource][_action][i].operator, policies[_resource][_action][i].attrValue); } return result; } /* @dev getPolicyItem get the policy item associate with specified attribute name */ function getPolicyItem( string memory _resource, string memory _action, string memory _attrName ) public view returns (PolicyItem[] memory) { require(policies[_resource][_action].length != 0, \u0026#34;getPolicyItem error: There is no policy for this resource and action at this time!\u0026#34;); PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length); uint num = 0; for (uint256 i = 0; i \u0026lt; policies[_resource][_action].length; i++) { if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) { result[num] = PolicyItem( policies[_resource][_action][i].attrOwner, _attrName, policies[_resource][_action][i].operator, policies[_resource][_action][i].attrValue); num++; } } return result; } /* @dev deletePolicy delete the policy associate with resource and specified action */ function deletePolicy(string memory _resource, string memory _action) public { require(msg.sender == manager, \u0026#34;deletePolicy error: Caller is not manager!\u0026#34;); require(policies[_resource][_action].length != 0, \u0026#34;deletePolicy error: There is no policy for this resource and action at this time!\u0026#34;); delete policies[_resource][_action]; rc.reputationCompute(msg.sender, false, 3, \u0026#34;Policy delete\u0026#34;, now); } /* @dev deletePolicyItem delete the policy item associate with specified attribute name */ function deletePolicyItem(string memory _resource, string memory _action, string memory _attrName) public { require(msg.sender == manager, \u0026#34;deletePolicyItem error: Caller is not manager!\u0026#34;); require(policies[_resource][_action].length != 0, \u0026#34;deletePolicyItem error: There is no policy for this resource and action at this time!\u0026#34;); for (uint256 i = 0; i \u0026lt; policies[_resource][_action].length; i++) { if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) { delete policies[_resource][_action][i]; } } rc.reputationCompute(msg.sender, false, 3, \u0026#34;Policy item delete\u0026#34;, now); } /* @dev stringToUint is a utility fucntion used for convert number string to uint */ function stringToUint(string memory s) public pure returns (uint256 result) { bytes memory b = bytes(s); uint256 i; result = 0; for (i = 0; i \u0026lt; b.length; i++) { uint8 c = uint8(b[i]); if (c \u0026gt;= 48 \u0026amp;\u0026amp; c \u0026lt;= 57) { result = result * 10 + (c - 48); } } } /* @dev accessControl is core fucntion */ function accessControl(string memory _resource, string memory _action) public returns (bool) { address subject = msg.sender; string memory _curOwner; string memory _curAttrName; string memory _curOperator; string memory _curAttrValue; string memory _attrValue; bool policycheck = true; bool behaviorcheck = true; uint8 errcode; bool result; if (mc.getTimeofUnblock(subject) \u0026gt;= now) { //still blocked state  errcode = 1; // Requests are blocked!  }else{ //unblocked state  if ((now - behaviors[subject].ToLR) \u0026lt;= evAttr.minInterval) { behaviors[subject].NoFR++; if (behaviors[subject].NoFR \u0026gt;= evAttr.threshold) { behaviorcheck = false; } }else{ behaviors[subject].NoFR = 0; } } //check policies  for (uint256 i = 0; i \u0026lt; policies[_resource][_action].length; i++) { _curOwner = policies[_resource][_action][i].attrOwner; _curAttrName = policies[_resource][_action][i].attrName; _curOperator = policies[_resource][_action][i].operator; _curAttrValue = policies[_resource][_action][i].attrValue; if (stringCompare(_curOwner,\u0026#34;subject\u0026#34;)) { if (stringCompare(_curAttrName, \u0026#34;deviceID\u0026#34;) || stringCompare(_curAttrName, \u0026#34;deviceType\u0026#34;) || stringCompare(_curAttrName, \u0026#34;deviceRole\u0026#34;)) { _attrValue = mc.getFixedAttribute(subject, _curAttrName); }else{ _attrValue = mc.getCustomedAttribute(subject, _curAttrName); } } else { _attrValue = resources[_resource][_curAttrName].value; } if (stringCompare(_curOperator,\u0026#34;\u0026gt;\u0026#34;) \u0026amp;\u0026amp; (stringToUint(_attrValue) \u0026lt;= stringToUint(_curAttrValue))) { policycheck = false; } if (stringCompare(_curOperator,\u0026#34;\u0026lt;\u0026#34;) \u0026amp;\u0026amp; (stringToUint(_attrValue) \u0026gt;= stringToUint(_curAttrValue))) { policycheck = false; } if (stringCompare(_curOperator,\u0026#34;=\u0026#34;) \u0026amp;\u0026amp; (!stringCompare(_attrValue,_curAttrValue))) { policycheck = false; } } if (policycheck \u0026amp;\u0026amp; !behaviorcheck) errcode = 2; //Static check failed!  if (!policycheck \u0026amp;\u0026amp; behaviorcheck) errcode = 3; //Misbehavior detected!  if (!policycheck \u0026amp;\u0026amp; !behaviorcheck) errcode = 4; //Static check failed and Misbehavior detected  behaviors[subject].ToLR = now; result = policycheck \u0026amp;\u0026amp; behaviorcheck; if (errcode == 0) { rc.reputationCompute(subject, false, 3, \u0026#34;Access authorized\u0026#34;, now); emit ReturnAccessResult(subject, true, \u0026#34;Access authorized\u0026#34;, now); } if (errcode == 1) { rc.reputationCompute(subject, true, 0, \u0026#34;Blocked end time not reached\u0026#34;, now); emit ReturnAccessResult(subject, false, \u0026#34;Blocked end time not reached\u0026#34;, now); } if (errcode == 2) { rc.reputationCompute(subject, true, 1, \u0026#34;Too frequent access\u0026#34;, now); emit ReturnAccessResult(subject, false, \u0026#34;Too frequent access\u0026#34;, now); } if (errcode == 3) { rc.reputationCompute(subject, true, 0, \u0026#34;Policy check failed\u0026#34;, now); emit ReturnAccessResult(subject, false, \u0026#34;Policy check failed\u0026#34;, now); } if (errcode == 4) { rc.reputationCompute(subject, true, 1, \u0026#34;Policy check failed and Too frequent access\u0026#34;, now); emit ReturnAccessResult(subject, false, \u0026#34;Policy check failed and Too frequent access\u0026#34;, now); } return result; } function deleteACC() public { require(msg.sender == manager, \u0026#34;Caller is not manager!\u0026#34;); selfdestruct(msg.sender); } } contract Reputation { function reputationCompute( address _subject, bool _ismisbehavior, uint8 _behaviorID, string memory _behavior, uint256 _time ) public; } contract Management { function getTimeofUnblock(address _device) public returns (uint256); function getFixedAttribute (address _device, string memory _attrName) public view returns (string memory _attrValue); function getCustomedAttribute(address _device, string memory _attrName) public view returns (string memory _attrValue); }   \r\r \r\rManagement.sol\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287  pragma solidity \u0026gt;=0.4.22 \u0026lt;0.7.0; /* @title: Manage smart contracts and device attributes @author: shuzang */ contract Management { address public owner; Reputation public rc; struct RContract{ bool isValued; //for duplicate check  address creator; //the peer(account) who created and deployed reputation contract  address scAddress; //the address of the smart contract  } struct attrValue{ bool isValued; string value; } struct Device { bool isValued; //for duplicate check  address manager; //the address of gateway which device belong to, for the gateway ,this filed is itself  address scAddress; //the address of access control contract associate with device  string deviceID; //the unique ID of device  string deviceType; //device type,e.g. Loudness Sensor  string deviceRole; //device role,e.g. validator, manager or device  uint256 TimeofUnblock; //time when the resource is unblocked (0 if unblocked, otherwise, blocked)  mapping (string =\u0026gt; attrValue) customed; //other attribute self customed,can have no element  } /* Mapping is marked internal, and write own getter function */ RContract public rct; mapping(address =\u0026gt; Device) internal LookupTable; mapping(address =\u0026gt; bool) internal isACCAddress; // judge if a address is a access control contract address, used by Reputation contract  /** * @dev Set contract deployer as owner */ constructor() public { owner = msg.sender; // \u0026#39;msg.sender\u0026#39; is sender of current call, contract deployer for a constructor  } /* @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption */ function stringCompare(string memory a, string memory b) internal pure returns (bool) { bytes memory _a = bytes(a); bytes memory _b = bytes(b); if (_a.length != _b.length) { return false; }else{ if (_a.length == 1) { return _a[0] == _b[0]; }else{ return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)); } } } /* @dev: setRC */ function setRC(address _rc, address _creator) public { //duplicate unchecked  require( !rct.isValued, \u0026#34;setRC error: Reputation contract already exist!\u0026#34; ); require( msg.sender == owner || msg.sender == _creator, \u0026#34;setRC error: Only mc owner or rc creator can register!\u0026#34; ); // register  rct.creator = _creator; rct.scAddress = _rc; rct.isValued = true; // setting for contract calls  rc = Reputation(_rc); } /* @dev update the information (i.e., scAddress) of a registered reputation contract */ function updateRC(address _rc) public { require(rct.isValued, \u0026#34;Reputation contract not exist!\u0026#34;); require( msg.sender == owner || msg.sender == rct.creator, \u0026#34;updateRC error: Only mc owner or rc creator can update RC!\u0026#34; ); rct.scAddress = _rc; rc = Reputation(_rc); } /* @dev deviceRegister register device attributes */ function deviceRegister( address _device, address _manager, address _scAddress, string memory _deviceID, string memory _deviceType, string memory _deviceRole) public { require ( !LookupTable[_device].isValued, \u0026#34;deviceRegister error: device already registered\u0026#34; ); require( msg.sender == _manager, \u0026#34;deviceRegister error: Only manager of device can register!\u0026#34; ); LookupTable[_device].manager = _manager; LookupTable[_device].scAddress = _scAddress; LookupTable[_device].deviceID = _deviceID; LookupTable[_device].deviceType = _deviceType; LookupTable[_device].deviceRole = _deviceRole; LookupTable[_device].TimeofUnblock = 0; LookupTable[_device].isValued = true; //rc.reputationCompute(msg.sender, false, 1, \u0026#34;Device register\u0026#34;, now ); //设备注册事件提交会触发阻塞时间更新的的回调，回调时设备未注册陷入死循环  isACCAddress[_scAddress] = true; } /* @dev addAttribute add additional attribute to the device */ function addAttribute ( address _device, string memory _attrName, string memory _attrValue) public { require(LookupTable[_device].isValued, \u0026#34;addAttribute error: Device not registered!\u0026#34;); require ( msg.sender == LookupTable[_device].manager, \u0026#34;add Attribute error: Only manager can add attribute!\u0026#34; ); require( !LookupTable[_device].customed[_attrName].isValued, \u0026#34;add Attribute error: Attribute already exist!\u0026#34; ); LookupTable[_device].customed[_attrName].value = _attrValue; LookupTable[_device].customed[_attrName].isValued = true; rc.reputationCompute(msg.sender, false, 1, \u0026#34;Attribute add\u0026#34;, now); } /* @dev updateManager update the manager of device */ function updateManager (address _device, address _newManager) public { require(LookupTable[_device].isValued, \u0026#34;updateManager error: Device not registered!\u0026#34;); require ( msg.sender == owner || msg.sender == LookupTable[_device].manager, \u0026#34;updateManager error: Only mc owner or device manager can update device manager!\u0026#34; ); LookupTable[_device].manager = _newManager; rc.reputationCompute(msg.sender, false, 2, \u0026#34;Device manager update\u0026#34;, now); } /* @dev updateAttribute update attribute of device */ function updateAttribute ( address _device, string memory _attrName, string memory _attrValue) public { require(LookupTable[_device].isValued, \u0026#34;updateAttribute error: Device not registered!\u0026#34;); require ( msg.sender == LookupTable[_device].manager, \u0026#34;updateAttribute error: Only manager can update Attribute!\u0026#34; ); require( LookupTable[_device].customed[_attrName].isValued, \u0026#34;updateAttribute error: Attribute not exist!\u0026#34; ); LookupTable[_device].customed[_attrName].value = _attrValue; rc.reputationCompute(msg.sender, false, 2, \u0026#34;Device customed attribute update\u0026#34;, now); } /* @dev updateTimeofUnblock update the time of unblocked, @notice this fucntion only can be call by reputation contract */ function updateTimeofUnblock(address _device, uint256 _TimeofUnblock) public { require(LookupTable[_device].isValued, \u0026#34;updateTimeofUnblock error: Device not registered!\u0026#34;); require(msg.sender == rct.scAddress, \u0026#34;updateTimeofUnblock error: Only reputation contract can update time of unblock!\u0026#34;); LookupTable[_device].TimeofUnblock = _TimeofUnblock; } /* @getFixedAttribute get the fixed device attribute(type is string) */ function getFixedAttribute (address _device, string memory _attrName) public view returns (string memory _attrValue) { require(LookupTable[_device].isValued, \u0026#34;getFixedAttribute error: Device not registered!\u0026#34;); require( stringCompare(_attrName, \u0026#34;deviceID\u0026#34;) || stringCompare(_attrName,\u0026#34;deviceType\u0026#34;) || stringCompare(_attrName,\u0026#34;deviceRole\u0026#34;), \u0026#34;getFixedAttribute error: The attribute passed in is not a device fixed attribute, please check the spelling or call getCustomedAttribute().\u0026#34; ); if (stringCompare(_attrName, \u0026#34;deviceID\u0026#34;)) { return LookupTable[_device].deviceID; } if (stringCompare(_attrName,\u0026#34;deviceType\u0026#34;)) { return LookupTable[_device].deviceType; } if (stringCompare(_attrName,\u0026#34;deviceRole\u0026#34;)) { return LookupTable[_device].deviceRole; } } /* @getDeviceRelatedAddress get the fixed device attribute(type is address) */ function getDeviceRelatedAddress(address _device, string memory _attrName) public view returns (address _attrValue) { require(LookupTable[_device].isValued, \u0026#34;getDeviceRelatedAddress error: Device not registered!\u0026#34;); if (stringCompare(_attrName, \u0026#34;manager\u0026#34;)) { return LookupTable[_device].manager; } if (stringCompare(_attrName, \u0026#34;scAddress\u0026#34;)) { return LookupTable[_device].scAddress; } } /* @getCustomedAttribute get the customed attribute */ function getCustomedAttribute(address _device, string memory _attrName) public view returns (string memory _attrValue) { require(LookupTable[_device].isValued, \u0026#34;getCustomedAttribute error: Device not registered!\u0026#34;); require( LookupTable[_device].customed[_attrName].isValued, \u0026#34;getCustomedAttribute error: Attribute not exist!\u0026#34; ); return LookupTable[_device].customed[_attrName].value; } function getTimeofUnblock(address _device) public view returns (uint256) { require(LookupTable[_device].isValued, \u0026#34;getTimeofUnblock error: Device not registered!\u0026#34;); return LookupTable[_device].TimeofUnblock; } function isContractAddress(address _scAddress) public view returns (bool) { return isACCAddress[_scAddress]; } /* @dev deleteDevice remove device from registered list */ function deleteDevice(address _device) public { require(LookupTable[_device].isValued, \u0026#34;deleteDevice error: Device not registered!\u0026#34;); require ( msg.sender == LookupTable[_device].manager, \u0026#34;deleteDevice error: Only manager can remove device!\u0026#34; ); delete LookupTable[_device]; delete isACCAddress[LookupTable[_device].scAddress]; rc.reputationCompute(msg.sender, false, 3, \u0026#34;Device delete\u0026#34;, now); } /* @dev deleteAttribute delete customed attribute */ function deleteAttribute(address _device, string memory _attrName) public { require(LookupTable[_device].isValued, \u0026#34;deleteAttribute error: device not exist!\u0026#34;); require ( msg.sender == LookupTable[_device].manager, \u0026#34;deleteAttribute error: Only owner can delete attribute!\u0026#34; ); require ( LookupTable[_device].customed[_attrName].isValued, \u0026#34;deleteAttribute error: Attribute not exist!\u0026#34; ); delete LookupTable[_device].customed[_attrName]; rc.reputationCompute(msg.sender, false, 3, \u0026#34;Attribute delete\u0026#34;, now); } } contract Reputation { function reputationCompute( address _subject, bool _ismisbehavior, uint8 _behaviorID, string memory _behavior, uint256 _time ) public; }   \r\r \r\rReputation.sol\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171  pragma solidity \u0026gt;=0.4.22 \u0026lt;0.7.0; contract Reputation { address public owner; address public mcAddress; Management public mc; event isCalled(address indexed _from, bool indexed _ismisbehavior, string indexed _behavior, uint _time, int Cr, uint Tblocked); struct BehaviorRecord { uint8 behaviorID; string behavior; uint time; uint8 currentWeight; } struct Behaviors { BehaviorRecord[] LegalBehaviors; BehaviorRecord[] MisBehaviors; uint begin; // begin index of legalBehaviors, when misbehaviors compute, this field recalculate  uint TimeofUnblock; //End time of blocked (0 if unblocked, otherwise, blocked)  } struct Environment { uint8[4] omega; uint8[2] alpha; //penalty factor, index 0 is illegal attribute or policy action, index 1 is access failed, index 2 is large number of requests in a short time  uint8 CrPmax; uint8 gamma; } //mapping devie address =\u0026gt; Behavior recort for reputation compute  mapping(address =\u0026gt; Behaviors) public behaviorsLookup; //some environment factors  Environment public evAttr; /** * @dev Set contract deployer as owner, set management contract address, initial environment variable */ constructor(address _mc) public { owner = msg.sender; mc = Management(_mc); mcAddress = _mc; initEnvironment(); } /* @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption */ function stringCompare(string memory a, string memory b) internal pure returns (bool) { bytes memory _a = bytes(a); bytes memory _b = bytes(b); if (_a.length != _b.length) { return false; }else{ if (_a.length == 1) { return _a[0] == _b[0]; }else{ return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)); } } } /* @dev initEnvironment initial parameters of reputation function */ function initEnvironment() internal { evAttr.alpha[0] = 1; // access control failed  evAttr.alpha[1] = 5; // Too frequent request  evAttr.omega[0] = 1; evAttr.omega[1] = 1; evAttr.omega[2] = 1; evAttr.omega[3] = 2; evAttr.CrPmax = 30; evAttr.gamma = 0; } /* @ dev updateEnvironment update parameters of reputation function */ function updateEnvironment(string memory _name, uint256 index, uint8 value) public { require( msg.sender == owner, \u0026#34;updateEnvironment error: Only owner can update environment factors!\u0026#34; ); if (stringCompare(_name, \u0026#34;omega\u0026#34;)) { evAttr.omega[index] = value; } if (stringCompare(_name, \u0026#34;alpha\u0026#34;)) { evAttr.alpha[index] = value; } if (stringCompare(_name, \u0026#34;CrPmax\u0026#34;)) { evAttr.CrPmax = value; } if (stringCompare(_name, \u0026#34;gamma\u0026#34;)) { evAttr.gamma = value; } } /* @dev reputationCompute compute the positive impact part and negative impact part of credit value, and then, compute blocked time and reward time according the credit value and update the device attribute */ function reputationCompute( address _subject, bool _ismisbehavior, uint8 _behaviorID, string memory _behavior, uint _time) public { require( mc.isContractAddress(msg.sender) || msg.sender == mcAddress, \u0026#34;reputationCompute error: only acc or mc can call function!\u0026#34; ); uint CrN = 0; uint CrP = 0; uint Tblocked; if (_ismisbehavior) { behaviorsLookup[_subject].MisBehaviors.push(BehaviorRecord(_behaviorID, _behavior, _time, evAttr.alpha[_behaviorID])); }else{ behaviorsLookup[_subject].LegalBehaviors.push(BehaviorRecord(_behaviorID, _behavior, _time, evAttr.omega[_behaviorID])); } for (uint i=0;i \u0026lt; behaviorsLookup[_subject].MisBehaviors.length; i++) { uint8 tmp = behaviorsLookup[_subject].MisBehaviors[i].currentWeight; CrN = CrN + tmp; if (tmp \u0026gt; 1) { behaviorsLookup[_subject].MisBehaviors[i].currentWeight = tmp - 1; } } for (uint i=behaviorsLookup[_subject].begin; i \u0026lt; behaviorsLookup[_subject].LegalBehaviors.length; i++) { CrP = CrP + behaviorsLookup[_subject].LegalBehaviors[i].currentWeight; } if ((now \u0026gt; behaviorsLookup[_subject].TimeofUnblock) \u0026amp;\u0026amp; (int(CrP - CrN) \u0026lt; evAttr.gamma)) { behaviorsLookup[_subject].begin = behaviorsLookup[_subject].LegalBehaviors.length-1; Tblocked = 2**(CrN-CrP); behaviorsLookup[_subject].TimeofUnblock = now + Tblocked; mc.updateTimeofUnblock(_subject, behaviorsLookup[_subject].TimeofUnblock); } emit isCalled(_subject, _ismisbehavior, _behavior, _time, int(CrP-CrN), Tblocked); } /* @dev getLastBehavior get the latest behavior condition */ function getLastBehavior(address _requester, uint8 _behaviorType) public view returns (uint _behaviorID, string memory _behavior, uint _time) { uint latest; if (_behaviorType == 0) { require(behaviorsLookup[_requester].LegalBehaviors.length \u0026gt; 0, \u0026#34;There is currently no legal behavior\u0026#34;); latest = behaviorsLookup[_requester].LegalBehaviors.length - 1; _behaviorID = behaviorsLookup[_requester].LegalBehaviors[latest].behaviorID; _behavior = behaviorsLookup[_requester].LegalBehaviors[latest].behavior; _time = behaviorsLookup[_requester].LegalBehaviors[latest].time; }else{ require(behaviorsLookup[_requester].MisBehaviors.length \u0026gt;= 0, \u0026#34;There is currently no misbehavior\u0026#34;); latest = behaviorsLookup[_requester].MisBehaviors.length - 1; _behaviorID = behaviorsLookup[_requester].MisBehaviors[latest].behaviorID; _behavior = behaviorsLookup[_requester].MisBehaviors[latest].behavior; _time = behaviorsLookup[_requester].MisBehaviors[latest].time; } } } contract Management { function updateTimeofUnblock(address _device, uint256 _TimeofUnblock) public; function isContractAddress(address _scAddress) public view returns (bool); }   \r\r 实验复现文档：\nhttps://shuzang.github.io/2020/experimental-process-optimization-and-performance-test/\n源代码仓库：\nhttps://github.com/shuzang/Access-control-contracts-for-IoT\n","description":"","id":1,"section":"posts","tags":["学术","区块链","智能合约"],"title":"复现BBRAC","uri":"https://moyahuang.github.io/zh/posts/%E5%A4%8D%E7%8E%B0bbrac/"},{"content":"在我众多弱点中最让我感觉到棘手的就是口语表达能力。即使是一个没有任何影响力的普通人，如果能够清晰精准甚至形象诙谐地表达自己的观点，描绘一个故事，多酷！高中以前生活的环境相对比较闭塞，在大学之后，越来越多的场合需要表达，遇见越来越多的人，越来越想要和另一个灵魂切磋打架。经验和科学可证，写作和说话可以激活大脑并帮助自己捋清思维，即使犯错，学会正确看待错误，能够形成一种正向循环。\n虽然理性来讲，无论是男女老少，都应该能给我们一些触动。但是不得不承认，作为一个女生，我更容易受到女性形象的影响，更容易让我产生一种“啊，我也想要”的冲动。下面列举一些我看着很有共鸣、很欢乐，或者印象很深的一些访谈。这些访谈中人物的表达能力（无关乎内容），让我“啊，我也想要这种能力”。\n 我上了大学之后，打算做一个学术女。至少年轻的时候，趁着自己的感情空白期，好好地用知识填补一下内心的空虚吧（笑）。 因为谈不了恋爱就只能做学术女，因为越是学术女就更谈不了恋爱，所以人生就构成了一个恶性循环。 我是身上种种厚厚的靠谱遮掩下还隐藏着一颗不靠谱而可爱的内心。 主持人：你是如何征婚的？答：我知道口风不严的一些人和一些大喇叭似的人，（向他们）说自己空窗，哭嚎自己今年一定要谈恋爱，透过他们向社会各界放出消息。一些和尚院系的老师已经和我接洽说希望我参加他们的联谊活动。 相亲变成了两个杰出青年（两个都是公众人物）就目前国际局势以及国家大事发表各自的看法。 我自己对人生的期待其实并不是有一群可以一起去逛街或者随叫随到的朋友。人生那么长，认识的人那么多，你的圈子那么大，但是驻守在你人生里的可能真的只有一小圈气场相投、莫失莫忘的朋友。我只要找到这么一小撮人就可以了。我不希望所有人都喜欢我，所有人都能跟我谈到一起去，我不期待这样的生活。 晚上睡觉之前躺在床上，心里连个念想都没有，唯一想到的就是也无风雨也无无情，然后沉沉地睡去。真的连那种让你辗转反侧，心跳加速，夜不成眠的悸动都没有，然后就每天睡死过去。 我重新看我这一两年的记录，我发现仍然是观点大过生活，断语大过经历，没什么改观，仍然是一个生活的记录者和旁观者。 别人世界的一根火柴可以把我的世界烧个精光。 如果说我有超能力，可能是我的敏感和延伸的能力，可以把一件细节的事情延伸到无限长，挖掘到无限深。但与此对应的是生活的无能力。 成名过早（12岁成名）接踵而至的是各种各样的争议、打击和对你未来的预告。每一次应战你身上都会多一层盔甲。现在应战十年，你变成一个没有死穴，盔甲很重的人，这太可怕了。用文艺女青年的话来说，没有东西能够“击中你柔软的心房”，我觉得实在太不可爱了。  \r   我想要承担我以天下为己任的责任，我想为往圣继绝学，为万世开太平。我想要承担这些责任，所以才会抑郁。（但我庆幸自己）不是只是躺尸就觉得开心。 我最害怕的是别人期待我有多厉害。北大学生大部分都是正常人、凡人，我不了解的事情，我跟你的认知水平是一样的。你问我对什么事有什么意见，指望我很哇塞地给你很哇塞的答案，我希望大家不要这么认知我。 人的选择是非常有限的，社会是一个结构。人和社会是互构的，结构对人有限制，人对结构有改变。人陷在这个结构里只能这样选。 你问一个青年，你有什么目标。他可能没有什么目标，但就是压力好大好大。 现代人永远不满足，永远在进步，但永远不知道自己在往什么方向进步。 出路是跟不喜欢的东西做对抗，但对抗的姿态可能也不是一个持久的、自足的姿态。 人这个肉体的形态会受损，他有一个消亡过程。  \r  光看文字，这两段摘录其实大体都只是些中性的观点输出。但或是细微的语言、情绪，或是采访者的年龄，这两段访谈给我两种不同观感，前一段欢脱，后一段些微沉重。很多观点我都有共鸣，但同样的观点，我的表达可能不会那么生动，那么在点子上。因此，我希望我也可以自由地用语言表达自己，不让口拙限制自己的思维。\n好像“想太多”的人很容易变得不快乐，会给别人带来一些压力。我号称自己是人间观察者、表达者、思考者，其实不希望自己也陷入这种没来由的深沉。或许可以找到一种平衡点，深刻但快乐。\n","description":"","id":2,"section":"posts","tags":["杂谈"],"title":"我为什么对思想输出开始有了冲动","uri":"https://moyahuang.github.io/zh/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E6%80%9D%E6%83%B3%E8%BE%93%E5%87%BA%E5%BC%80%E5%A7%8B%E6%9C%89%E4%BA%86%E5%86%B2%E5%8A%A8/"},{"content":"搞科研一定要注意：不要用商业性和实用性去苛求科研。例如，本文仅仅验证了系统可行性，是少量设备、理想环境下的一种演示。在性能、安全、隐私、可扩展性等方面必然存在问题，这些问题可以作为我科研的研究点进行改进，或者去探索其他的可行性。 论文引文信息（in Chicago） Zhang, Yuanyu, Shoji Kasahara, Yulong Shen, Xiaohong Jiang, and Jianxiong Wan. \u0026ldquo;Smart contract-based access control for the internet of things.\u0026rdquo; IEEE Internet of Things Journal 6, no. 2 (2018): 1594-1605.\npdf\r\r\n论文分析 论文概述 论文设计了三种类型的智能合约用于实现访问控制，分别作用如下：\n访问控制合约（ACC）：为每个主客体对创建一个智能合约\n仲裁合约（JC）：被ACC实例调用，用于获取对异常行为（i.e.频繁访问）的处罚（i.e.禁止访问时长）\n注册合约（RC）：注册ACC和JC的合约地址以及ABI\n三种合约之间的对应关系如下：\ngraph TB A(ACC1) -- register --\u0026gt; B(RC) C(ACC2) -- register --\u0026gt; B(RC) D(ACC3) -- register --\u0026gt; B(RC) E(...) -- register --\u0026gt; B(RC) F(JC) -- register --\u0026gt; B(RC) style F fill:#28AFB0 style B fill:#F4D35E graph TB A(ACC1) -- call --\u0026gt; F(JC) C(ACC2) -- call --\u0026gt; F(JC) D(ACC3) -- call --\u0026gt; F(JC) E(...) -- call --\u0026gt; F(JC) style F fill:#28AFB0 ACC 本文为每个资源都保存了一个异常行为记录，代码中用behaviors[resourceID]（behaviors对应客体所有资源的异常行为列表）保存，BehaviorItem（即每个资源的异常行为列表）表示，记录保存内容如下：\n   Misbehavior Time Penalty     Too frequent access 2020-12-16 21:00 blocked for 2 hours   Too frequent access 2020-12-16 21:30 blocked for 2 hours    访问权限的仲裁依据为由资源拥有者预先定义的访问规则列表，也叫做访问控制列表(ACL)。本文中的访问控制列表与智能合约对应的单一的主客体对（subject-object pair）对应，以资源为单位进行划分，如下：\n   Resource Action Permission ToLR(Time of Last Request)     file A read deny 2020-12-16 21:00   file B write deny 2020-12-16 21:20   program A execute allow 2020-12-16 21:30    ACC由客体（即资源拥有者）发布。因此在构造函数中把主体作为参数传入，客体和资源拥有者指定为ACC合约发布者。\nsetJC: ACC提供了一个设置JC的函数，智能合约的创建者能够修改JC，同时表示JC可更换。\npolicyAdd: 注意该方法使用policy的属性isValued表示对应记录是否赋值，同时可以防止policy重复添加。\ngetPolicy: 获取访问策略的函数, 有两个参数(_resource, _action)，这意味着访问控制列表的粒度细到action。\naccessControl: 若访问的时间已经过了禁止访问的时间点，则先将资源异常行为列表的禁止访问时间置0，对应(_resource, _action)的NoFR及ToLR置0。访问策略和访问行为同时满足需求才可以访问。\nNoFR: 累积到一定阈值会被认定为频繁访问。\nJC 本文的JC主要是为了保存主体异常行为列表MisbehaviorList，根据主体异常行为的次数增加其对应主体的禁止访问时间。\nRC ACC及JC的函数都要在这里注册，函数用函数名进行标识。用户可以从这里通过函数名获取合约地址及函数ABI。\nregisterACC 使用RC methods对应的JSON对象获取JC(?) 当调用methodRegister时向区块链发送事务。\n我的问题  本文中为每一个主客体对创建其对应智能合约，不适合大规模应用场景下 是否存在隐私安全问题 源码中异常行为的判断逻辑在ACC中，而不是JC，这意味着仲裁逻辑不能被复用 本文中的客体对应多种资源，客体维护了一张用资源和操作的访问策略列表（ACL，源码中用PolicyItem表示），但其实本文没有指明ACL的action一栏是否可指定多种操作，该项与访问控制粒度相关 RC存在的问题是通过函数名进行查询很容易出现重名的问题；更何况ACCs之间的函数名一定有重合 规则的添加过于麻烦，需要手动为每一个资源添加规则 没有访问授权机制 分布式访问控制的特性是不是就是由资源方控制访问策略，但是ACC的构造函数需要为每一个主体（访问者，这个访问者的粒度大小多少）创建一个智能合约 ACC提供了getPolicy方法是否存在隐私安全问题（待测试）？因为智能合约本身与主客体对对应，所以明确访问某个智能合约，即明确查询某一个主客体对的访问策略，这是否存在实际意义？用户是谁，如何明确获知某一对主客体对对一个的智能合约地址。 本文是区块链  源码分析 classDiagram class AccessControl { +address owner +address subject +address object Judge public jc struct Misbehavior struct BehaviorItem struct PolicyItem mapping[resource][action] policies mapping[resource] behaviors +AccessControlMethod(_subject) +setJC(_jc) +policyAdd(_resource, _action, _permission, _minInterval, _threshold) +getPolicy(string _resource, string _action) : (_permission, _minInterval, _threshold, _ToLR, _NoFR, _res, _errcode) +policyUpdate(string _resource, string _action, string _newPermission) +minIntervalUpdate(_resource, _action, _newMinInterval) +thresholdUpdate( _resource, _action, _newThreshold) +policyDelete(_resource, _action) +accessControl(_resource, _action, _time) -\u0026gt; emit +getTimeofUnblock(_resource) : (_penalty, _timeOfUnblock) +deleteACC() } AccessControl o-- Judge class Judge { +uint base +uint interval +address owner struct Misbehavior +mapping[subject] MisbehaviorList +Judge(_base, _interval) +misbehaviorJudge(_subject, _object, _res, _action, _misbehavior, _time) : penalty -\u0026gt; emit +getLatestMisbehavior(_key) : (_subject, _object, _res, _action, _misbehavior, _time) +self_destruct() } class Register{ struct Method +mapping[method] lookupTable +methodRegister(_methodName, _scname, _subject, _object, _creator, _scAddress, _abi) +methodScNameUpdate(_methodName, _scName) +methodAcAddressUpdate(_methodName, _scAddress) +methodAbiUpdate(_methodName, _abi) +methodNameUpdate(_oldName, _newName) +methodDelete(_name) +getContractAddr(_methodName) : _scAddressp +getContractAbi(_methodName) : _abi } Register \u0026lt;-- AccessControl Register \u0026lt;-- Judge 论文源代码 智能合约 Access Control Contract, one per subject-object pair\n\r\rACC\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234  pragma solidity ^0.4.0; contract AccessControlMethod{ address public owner; address public subject; address public object; Judge public jc; event ReturnAccessResult( address indexed _from, string _errmsg, bool _result, uint _time, uint _penalty ); struct Misbehavior{ string res; //resource on which the misbehavior is conducted  string action; //action (e.g., \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;execute\u0026#34;) of the misbehavior  string misbehavior; //misbehavior  uint time; //time of the misbehavior occured  uint penalty; //penalty opposed to the subject (number of minutes blocked)  } struct BehaviorItem{ //for one resource  Misbehavior [] mbs; //misbehavior list of the subject on a particular resource  uint TimeofUnblock; //time when the resource is unblocked (0 if unblocked; otherwise,blocked)  } struct PolicyItem{ //for one (resource, action) pair;  bool isValued; //for duplicate check  string permission; //permission: \u0026#34;allow\u0026#34; or \u0026#34;deny\u0026#34;  uint minInterval; //minimum allowable interval (in seconds) between two successive requests  uint ToLR; //Time of Last Request  uint NoFR; //Number of frequent Requests in a short period of time  uint threshold; //threshold on NoFR, above which a misbehavior is suspected  bool result; //last access result  uint8 err; //last err code  } mapping (bytes32 =\u0026gt; mapping(bytes32 =\u0026gt; PolicyItem)) policies; //mapping (resource, action) =\u0026gt;PolicyCriteria for policy check  mapping (bytes32 =\u0026gt; BehaviorItem) behaviors; //mapping resource =\u0026gt; BehaviorCriteria for behavior check  /*convert strings to byte32*/ function stringToBytes32(string _str) public constant returns (bytes32){ bytes memory tempBytes = bytes(_str); bytes32 convertedBytes; if(0 == tempBytes.length){ return 0x0; } assembly { convertedBytes := mload(add(_str, 32)) } return convertedBytes; } function AccessControlMethod(address _subject) public{ owner = msg.sender; object = msg.sender; subject = _subject; } function setJC(address _jc)public{ if(owner == msg.sender){ jc = Judge(_jc); } else throw; } function policyAdd(string _resource, string _action, string _permission, uint _minInterval, uint _threshold) public{ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(msg.sender == owner){ if(policies[resource][action].isValued) throw; //duplicated key  else{ policies[resource][action].permission = _permission; policies[resource][action].minInterval = _minInterval; policies[resource][action].threshold = _threshold; policies[resource][action].ToLR = 0; policies[resource][action].NoFR = 0; policies[resource][action].isValued = true; policies[resource][action].result = false; behaviors[resource].TimeofUnblock = 0; } } else throw; } function getPolicy(string _resource, string _action) public constant returns (string _permission, uint _minInterval, uint _threshold, uint _ToLR, uint _NoFR, bool _res, uint8 _errcode){ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(policies[resource][action].isValued){ _permission = policies[resource][action].permission; _minInterval = policies[resource][action].minInterval; _threshold = policies[resource][action].threshold; _NoFR = policies[resource][action].NoFR; _ToLR = policies[resource][action].ToLR; _res = policies[resource][action].result; _errcode = policies[resource][action].err; } else throw; } function policyUpdate(string _resource, string _action, string _newPermission) public{ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(policies[resource][action].isValued){ policies[resource][action].permission = _newPermission; } else throw; } function minIntervalUpdate(string _resource, string _action, uint _newMinInterval) public{ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(policies[resource][action].isValued){ policies[resource][action].minInterval= _newMinInterval; } else throw; } function thresholdUpdate(string _resource, string _action, uint _newThreshold) public{ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(policies[resource][action].isValued){ policies[resource][action].threshold= _newThreshold; } else throw; } function policyDelete(string _resource, string _action) public{ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(msg.sender == owner){ if(policies[resource][action].isValued){ delete policies[resource][action]; } else throw; } else throw; } /*Use event*/ function accessControl(string _resource, string _action, uint _time) public{ bool policycheck = false; bool behaviorcheck = true; uint8 errcode = 0; uint penalty = 0; if (msg.sender == subject){ bytes32 resource = stringToBytes32(_resource); bytes32 action = stringToBytes32(_action); if(behaviors[resource].TimeofUnblock \u0026gt;= _time){//still blocked state  errcode = 1; //\u0026#34;Requests are blocked!\u0026#34;  } else{//unblocked state  if(behaviors[resource].TimeofUnblock \u0026gt; 0){ behaviors[resource].TimeofUnblock = 0; policies[resource][action].NoFR = 0; policies[resource][action].ToLR = 0; } //policy check  if (keccak256(\u0026#34;allow\u0026#34;) == keccak256(policies[resource][action].permission)){ policycheck = true; } else{ policycheck = false; } //behavior check  if (_time - policies[resource][action].ToLR \u0026lt;= policies[resource][action].minInterval){ policies[resource][action].NoFR++; if(policies[resource][action].NoFR \u0026gt;= policies[resource][action].threshold){ penalty = jc.misbehaviorJudge(subject, object, _resource, _action, \u0026#34;Too frequent access!\u0026#34;, _time); behaviorcheck = false; behaviors[resource].TimeofUnblock = _time + penalty * 1 minutes; behaviors[resource].mbs.push(Misbehavior(_resource, _action, \u0026#34;Too frequent access!\u0026#34;, _time, penalty));//problem occurs when using array  } } else{ policies[resource][action].NoFR = 0; } if(!policycheck \u0026amp;\u0026amp; behaviorcheck) errcode = 2; //\u0026#34;Static Check failed!\u0026#34;  if(policycheck \u0026amp;\u0026amp; !behaviorcheck) errcode = 3; //\u0026#34;Misbehavior detected!\u0026#34;  if(!policycheck \u0026amp;\u0026amp; !behaviorcheck) errcode = 4; //\u0026#34;Static check failed! \u0026amp; Misbehavior detected!\u0026#34;;  } policies[resource][action].ToLR = _time; } else { errcode = 5; //\u0026#34;Wrong object or subject detected!\u0026#34;;  } policies[resource][action].result = policycheck \u0026amp;\u0026amp; behaviorcheck; policies[resource][action].err = errcode; if(0 == errcode) ReturnAccessResult(msg.sender, \u0026#34;Access authorized!\u0026#34;, true, _time, penalty); if(1 == errcode) ReturnAccessResult(msg.sender, \u0026#34;Requests are blocked!\u0026#34;, false, _time, penalty); if(2 == errcode) ReturnAccessResult(msg.sender, \u0026#34;Static Check failed!\u0026#34;, false, _time, penalty); if(3 == errcode) ReturnAccessResult(msg.sender, \u0026#34;Misbehavior detected!\u0026#34;, false, _time, penalty); if(4 == errcode) ReturnAccessResult(msg.sender, \u0026#34;Static check failed! \u0026amp; Misbehavior detected!\u0026#34;, false, _time, penalty); if(5 == errcode) ReturnAccessResult(msg.sender, \u0026#34;Wrong object or subject specified!\u0026#34;, false, _time, penalty); } function getTimeofUnblock(string _resource) public constant returns(uint _penalty, uint _timeOfUnblock){ bytes32 resource= stringToBytes32(_resource); _timeOfUnblock = behaviors[resource].TimeofUnblock; uint l = behaviors[resource].mbs.length; _penalty = behaviors[resource].mbs[l - 1].penalty; } function deleteACC() public{ if(msg.sender == owner){ selfdestruct(this); } } } contract Judge{ function misbehaviorJudge(address _subject, address _object, string _res, string _action, string _misbehavior, uint _time) public returns (uint ); }   \r\r\nJudge Contract, called by ACC(s) to judge the misbehavior of subjects and return the corresponding penalty\n\r\rJC\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  pragma solidity ^0.4.0; contract Judge{ uint public base; uint public interval; address public owner; event isCalled(address _from, uint _time, uint _penalty); struct Misbehavior{ address subject; //subject who performed the misbehavior;  address object; //  string res; //  string action; //action (e.g., \u0026#34;read\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;execute\u0026#34;) of the misbehavior  string misbehavior; //misbehavior  uint time; //time of the Misbehavior occured  uint penalty; //penalty (number of minitues blocked);  } mapping (address =\u0026gt; Misbehavior[]) public MisbehaviorList; function Judge (uint _base, uint _interval) public{ base = _base; interval = _interval; owner = msg.sender; } function misbehaviorJudge(address _subject, address _object, string _res, string _action, string _misbehavior, uint _time) public returns (uint penalty){ //misbehaviorJudge(msb);  uint length = MisbehaviorList[_subject].length + 1; uint n = length/interval; penalty = base**n; MisbehaviorList[_subject].push(Misbehavior(_subject, _object, _res, _action, _misbehavior, _time, penalty)); isCalled(msg.sender,_time, penalty); } function getLatestMisbehavior(address _key) public constant returns (address _subject, address _object, string _res, string _action, string _misbehavior, uint _time){ uint latest = MisbehaviorList[_key].length - 1; //uint latest = 0;  _subject = MisbehaviorList[_key][latest].subject; _object = MisbehaviorList[_key][latest].object; _res = MisbehaviorList[_key][latest].res; _action = MisbehaviorList[_key][latest].action; _misbehavior = MisbehaviorList[_key][latest].misbehavior; _time = MisbehaviorList[_key][latest].time; } function self_destruct() public{ if(msg.sender == owner){ selfdestruct(this); } } }   \r\r\nRegister Contract, registering required information, such contract address and ABI for interacting with the ACCs and JC\n\r\rRC\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  pragma solidity ^0.4.0; contract Register{ struct Method{ string scName; //contract name  address subject; //the subject of the corresponding subject-object pair of the ACC; for the JC, this filed is left blank;  address object; //the subject of the corresponding subject-object pair of the ACC; for the JC, this filed is left blank;  address creator; //the peer (account) who created and deployed this contract;  address scAddress; //the address of the contract;  bytes abi; //the Abifs provided by the contract.  } /*As solidity cannot allow dynamically-sized value as the Key, we use the fixed-szie byte32 type as the keytype*/ mapping (bytes32=\u0026gt; Method) public lookupTable; /*convert strings to byte32*/ function stringToBytes32(string _str) public constant returns (bytes32){ bytes memory tempBytes = bytes(_str); bytes32 convertedBytes; if(0 == tempBytes.length){ return 0x0; } assembly { convertedBytes := mload(add(_str, 32)) } return convertedBytes; } /*register an access control contract (ACC)*/ function methodRegister(string _methodName, string _scname, address _subject, address _object, address _creator, address _scAddress, bytes _abi) public { //no duplicate check  bytes32 newKey = stringToBytes32(_methodName); lookupTable[newKey].scName = _scname; lookupTable[newKey].subject = _subject; lookupTable[newKey].object = _object; lookupTable[newKey].creator = _creator; lookupTable[newKey].scAddress = _scAddress; lookupTable[newKey].abi = _abi; } /*update the ACC information (i.e., scname, scAddress, abi) of an exisiting method specified by the _methodName*/ function methodScNameUpdate(string _methodName, string _scName) public{ bytes32 key = stringToBytes32(_methodName); lookupTable[key].scName = _scName; } function methodAcAddressUpdate(string _methodName, address _scAddress) public{ bytes32 key = stringToBytes32(_methodName); lookupTable[key].scAddress = _scAddress; } function methodAbiUpdate(string _methodName, bytes _abi) public{ bytes32 key = stringToBytes32(_methodName); lookupTable[key].abi = _abi; } /*update the name (_oldname) of an exisiting method with a new name (_newname) */ function methodNameUpdate(string _oldName, string _newName) public{ bytes32 oldKey = stringToBytes32(_oldName); bytes32 newKey = stringToBytes32(_newName); lookupTable[newKey].scName = lookupTable[oldKey].scName; lookupTable[newKey].subject = lookupTable[oldKey].subject; lookupTable[newKey].object = lookupTable[oldKey].object; lookupTable[newKey].creator = lookupTable[oldKey].creator; lookupTable[newKey].scAddress = lookupTable[oldKey].scAddress; lookupTable[newKey].abi = lookupTable[oldKey].abi; delete lookupTable[oldKey]; } function methodDelete(string _name) public{ delete lookupTable[stringToBytes32(_name)]; } function getContractAddr(string _methodName) public constant returns (address _scAddress){ bytes32 key = stringToBytes32(_methodName); _scAddress = lookupTable[key].scAddress; } function getContractAbi(string _methodName) public constant returns (bytes _abi){ bytes32 key = stringToBytes32(_methodName); _abi = lookupTable[key].abi; } }   \r\r\nJavaScript Registering an ACC in the JC\n\r\raccess_monitor.js\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248  var Web3 = require(\u0026#39;web3\u0026#39;); var web3 = new Web3(new Web3.providers.HttpProvider(\u0026#34;http://localhost:8545\u0026#34;)); var regAddr = \u0026#34;0xddf27a729d05be6f11be50b1905daa6e7b508c91\u0026#34;; var regAbi = [ { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_str\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;stringToBytes32\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;lookupTable\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;scName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;creator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getContractAddr\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getContractAbi\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodAbiUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodAcAddressUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodDelete\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_oldName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_newName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodNameUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_object\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_creator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodRegister\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodScNameUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; } ] var methodName = \u0026#34;Method1\u0026#34;; var register = web3.eth.contract(regAbi).at(regAddr); var accAddr = register.getContractAddr(methodName); var accAbiBytes = register.getContractAbi(methodName); var accAbi = JSON.parse(web3.toAscii(accAbiBytes)); var myACC = web3.eth.contract(accAbi).at(accAddr); var myEvent = myACC.ReturnAccessResult({fromBlock: 0, toBlock: \u0026#39;latest\u0026#39;}); myEvent.watch(function(err, result){ if(!err){ //console.log(result); \tconsole.log(\u0026#34;Contract: \u0026#34;+result.address); console.log(\u0026#34;Block Number: \u0026#34; + result.blockNumber); console.log(\u0026#34;Tx Hash: \u0026#34; + result.transactionHash); console.log(\u0026#34;Block Hash: \u0026#34;+ result.blockHash); console.log(\u0026#34;Subject: \u0026#34;+ result.args._from); console.log(\u0026#34;Time: \u0026#34; + result.args._time.toNumber()); console.log(\u0026#34;Message: \u0026#34; + result.args._errmsg); console.log(\u0026#34;Result: \u0026#34; + result.args._result); if (result.args._penalty \u0026gt; 0) console.log(\u0026#34;Requests are blocked for \u0026#34; + result.args._penalty + \u0026#34; minutes!\u0026#34;); console.log(\u0026#34;\\n\u0026#34;); } })   \r\r\nRetrieving the required information of an ACC and sending access reqeusts to this ACC for access control\n\r\raccess_request.js\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282  var Web3 = require(\u0026#39;web3\u0026#39;); var web3 = new Web3(new Web3.providers.HttpProvider(\u0026#34;http://localhost:8545\u0026#34;)); var subject = \u0026#34;0x0d1f8a489b1312689f11f7fe79dfc3b61ffa4160\u0026#34;; var regAddr = \u0026#34;0xddf27a729d05be6f11be50b1905daa6e7b508c91\u0026#34;; var regAbi = [ { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_str\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;stringToBytes32\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;lookupTable\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;scName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;creator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getContractAddr\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getContractAbi\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodAbiUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodAcAddressUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodDelete\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_oldName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_newName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodNameUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_object\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_creator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodRegister\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodScNameUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; } ]; var methodName = \u0026#34;Method1\u0026#34;; var register = web3.eth.contract(regAbi).at(regAddr); var accAddr = register.getContractAddr(methodName); var accAbiBytes = register.getContractAbi(methodName); var accAbi = JSON.parse(web3.toAscii(accAbiBytes)); var myACC = web3.eth.contract(accAbi).at(accAddr); var myEvent = myACC.ReturnAccessResult({_from: subject},{from: \u0026#39;latest\u0026#39;}); var previousTxHash = 0; var currentTxHash = 0; const readline = require(\u0026#39;readline\u0026#39;); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.setPrompt(\u0026#39;Send access request?(y/n)\u0026#39;); rl.prompt(); rl.on(\u0026#39;line\u0026#39;, (answer) =\u0026gt; { if(\u0026#39;y\u0026#39; == answer) { var currentTime = new Date().getTime()/1000; currentTxHash = myACC.accessControl.sendTransaction(\u0026#34;File A\u0026#34;, \u0026#34;write\u0026#34;, currentTime, {from: web3.eth.accounts[0]}); myEvent.watch(function(err, result){ if(!err){ if(previousTxHash != result.transactionHash \u0026amp;\u0026amp; currentTxHash == result.transactionHash){//avoid dupicate event captured  console.log(\u0026#34;Contract: \u0026#34;+result.address); console.log(\u0026#34;Block Number: \u0026#34; + result.blockNumber); console.log(\u0026#34;Tx Hash: \u0026#34; + result.transactionHash); console.log(\u0026#34;Block Hash: \u0026#34;+ result.blockHash); console.log(\u0026#34;Time: \u0026#34; + result.args._time.toNumber()); console.log(\u0026#34;Message: \u0026#34; + result.args._errmsg); console.log(\u0026#34;Result: \u0026#34; + result.args._result); if (result.args._penalty \u0026gt; 0) console.log(\u0026#34;Requests are blocked for \u0026#34; + result.args._penalty + \u0026#34; minutes!\u0026#34;); console.log(\u0026#39;\\n\u0026#39;); previousTxHash = result.transactionHash; rl.prompt(); } } }); } else{ console.log(\u0026#34;Ummmmm....\u0026#34;); rl.prompt(); } }); rl.on(\u0026#39;close\u0026#39;, function() { console.log(\u0026#39;Have a great day!\u0026#39;); process.exit(0); });   \r\r\nCalled by an object to watch the deployed ACC and retrive the access result when an access reqeust comes\n\r\rregisterACC.js\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586  var Web3 = require(\u0026#39;web3\u0026#39;); var web3 = new Web3(new Web3.providers.HttpProvider(\u0026#34;http://localhost:8545\u0026#34;)); var regAddr = \u0026#34;0xddf27a729d05be6f11be50b1905daa6e7b508c91\u0026#34;; var regAbi = [ { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_str\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;stringToBytes32\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;lookupTable\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;scName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;creator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getContractAddr\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getContractAbi\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodAbiUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodAcAddressUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodDelete\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_oldName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_newName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodNameUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_object\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_creator\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scAddress\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_abi\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodRegister\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_methodName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_scName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;methodScNameUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; } ]; var register = web3.eth.contract(regAbi).at(regAddr); var _methodName = \u0026#34;1\u0026#34;; var _scName = \u0026#34;2\u0026#34;; var _subject = \u0026#34;0x0d1f8a489b1312689f11f7fe79dfc3b61ffa4160\u0026#34;; var _object = \u0026#34;0x0d1f8a489b1312689f11f7fe79dfc3b61ffa4160\u0026#34;; var _creator = \u0026#34;0x0d1f8a489b1312689f11f7fe79dfc3b61ffa4160\u0026#34;; var _scAddr = \u0026#34;0x0d1f8a489b1312689f11f7fe79dfc3b61ffa4160\u0026#34;; var _abi = [ { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;subject\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_jc\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;setJC\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getPolicy\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_permission\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_minInterval\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_threshold\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_ToLR\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_NoFR\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_res\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bool\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_errcode\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint8\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;jc\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;policyDelete\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;owner\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_newThreshold\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;thresholdUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;getTimeofUnblock\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_penalty\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_timeOfUnblock\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_permission\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_minInterval\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_threshold\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;policyAdd\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_newMinInterval\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;minIntervalUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_time\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;accessControl\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: true, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_str\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;stringToBytes32\u0026#34;, \u0026#34;outputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bytes32\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;view\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_action\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;_newPermission\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;policyUpdate\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;constant\u0026#34;: false, \u0026#34;inputs\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;deleteACC\u0026#34;, \u0026#34;outputs\u0026#34;: [], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; }, { \u0026#34;inputs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;_subject\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; } ], \u0026#34;payable\u0026#34;: false, \u0026#34;stateMutability\u0026#34;: \u0026#34;nonpayable\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;constructor\u0026#34; }, { \u0026#34;anonymous\u0026#34;: false, \u0026#34;inputs\u0026#34;: [ { \u0026#34;indexed\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;_from\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;address\u0026#34; }, { \u0026#34;indexed\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;_errmsg\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;indexed\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;_result\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;bool\u0026#34; }, { \u0026#34;indexed\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;_time\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; }, { \u0026#34;indexed\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;_penalty\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;uint256\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;ReturnAccessResult\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;event\u0026#34; } ] register.methodRegister.sendTransaction(_methodName, _scName, _subject, _object, _creator, _scAddr, _abi, {from:web3.eth.coinbase, gas:3000000});   \r\r\n参考文献 [1] 源代码GitHub仓库\n[2] 论文链接\n","description":"","id":3,"section":"posts","tags":["学术","区块链","智能合约"],"title":"复现《Smart Contract Based Access Control for the Internet of Things》","uri":"https://moyahuang.github.io/zh/posts/%E5%A4%8D%E7%8E%B0smart-contract-based-access-control-for-the-internet-of-things/"},{"content":"Intro  Solidity   Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在以太坊虚拟机（EVM）上运行。\n  Remix   基于浏览器的 IDE，集成了编译器和 Solidity 运行时环境，不需要服务端组件。\n  MetaMask   MetaMask是通过浏览器访问分布式应用（dapps）的一个Chrome插件。可访问以太坊主网，任一以太坊测试网（Ropsten, Kovan, and Rinkeby），或者本地区块链。\n  Geth   Geth是Go Ethereum的缩写，是以太坊协议的三大原始实现之一（另外还有C++和Python），也是最受欢迎的客户端实现。它可以作为客户端运行在几乎任一操作系统上。安装了客户端的节点可以与其他节点建立p2p通信信道，签署和广播交易，挖掘，部署和与智能合约交互。\n启动Geth时，客户端会自动在端口8545启动RPC服务器。然后使用web3j等库连接到localhost：8545或使用curl或wget手动调用它来访问此端口的RPC服务器及其方法。\n  Web3.js   web.js是通过HTTP/IPC/WebSocket等协议用于和本地或远程以太坊节点进行交互的javascript库。\n  Quorum  简单的智能合约  Solidity第一行使用关键词pragma指定使用哪个版本编译器处理源代码。 event事件类型可以让监听该事件的listener收到通知，方便事务追踪。\n下面这个示例定义了一个事件，放在需要监听的函数最后执行：  1 2 3 4 5 6 7  event Sent(address from, address to, uint amount); function send(address receiver, uint amount) public { if (balances[msg.sender] \u0026lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); }   该事件可这样被监听:\n1 2 3 4 5 6 7 8 9 10  Coin.Sent().watch({}, \u0026#39;\u0026#39;, function(error, result) { if (!error) { console.log(\u0026#34;Coin transfer: \u0026#34; + result.args.amount + \u0026#34; coins were sent from \u0026#34; + result.args.from + \u0026#34; to \u0026#34; + result.args.to + \u0026#34;.\u0026#34;); console.log(\u0026#34;Balances now:\\n\u0026#34; + \u0026#34;Sender: \u0026#34; + Coin.balances.call(result.args.from) + \u0026#34;Receiver: \u0026#34; + Coin.balances.call(result.args.to)); } })   事件的参数可以通过上述回调函数的第二个参数的属性args访问，本例为result.args。\n经测试，事件监听要下面这样写才有效，可能是web3版本的问题\r 1 2 3 4 5  MetaCoinContract.events.Sent(function(err, result){ if(!err){ ... } })   全局变量msg,tx,block保存一些区块链的属性，其中msg.sender永远指向访问当前函数的来源地址（在构造函数中，msg.sender指向智能合约的创建者）  区块链基础 · 事务/交易(transaction)  区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。事务一词意味着你想做的（假设您想要同时更改两个值），要么一点没做，要么全部完成。此外，当你的事务被应用到数据库时，其他事务不能修改数据库。\n举个例子，设想一张表，列出电子货币中所有账户的余额。如果请求从一个账户转移到另一个账户，数据库的事务特性确保了如果从一个账户扣除金额，它总被添加到另一个账户。如果由于某些原因，无法添加金额到目标账户时，源账户也不会发生任何变化。\n此外，交易总是由发送人（创建者）签名。\n这样，就可非常简单地为数据库的特定修改增加访问保护机制。在电子货币的例子中，一个简单的检查可以确保只有持有账户密钥的人才能从中转账。\n 以太坊虚拟机 · 账号(account)  以太坊中有两类账户（它们共用同一个地址空间）： 外部账户(external accounts) 由公钥-私钥对（也就是人）控制； 合约账户(contract accounts) 由和账户一起存储的代码控制.\n外部账户的地址是由公钥决定的，而合约账户的地址是在创建该合约时确定的（这个地址通过合约创建者的地址和从该地址发出过的交易数量计算得到的，也就是所谓的“nonce”）\n无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。\n每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 存储(storage) 。\n此外，每个账户有一个以太币余额（ balance ）（最小单位是$Wei$, $1 ether=10^{18}Wei$），余额会因为发送包含以太币的交易而改变。\n · 交易(transaction)  交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。\n如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。\n如果目标账户是零账户（账户地址为 0 )，此交易将创建一个 新合约 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。\n · Gas  为了避免网络滥用及回避由于图灵完备而带来的一些不可避免的问题(the halting problem)，在以太坊中所有的程序执行都收费。Gas是基本的工作量成本单位，用于计量在以太坊区块链上执行操作所需的计算、存储资源和带宽，其目的是限制执行交易所需的工作量。各种操作的费用以gas为单位计算。任意的程序片段（包括合约创建、消息调用、分配资源以及访问账户storage、在虚拟机上执行操作等）都有一个普遍认同的gas成本。Gas有两个作用：\n 以太坊(不稳定的)价格和矿工工作报酬之间的缓冲 对拒绝服务(DoS)攻击的防御.  每一个交易都要指定一个 gas 上限：gasLimit。发送者通过在交易中指定gas price来购买gas，系统预先从发送者的账户余额中扣除gasLimit * gasPrice的交易费，即采用预付费机制。Gas price是指当你将交易发送到以太坊网络时，愿意支付的每单位gas的价格。如果账户余额不足，交易会被视为无效交易。之所以将其命名为 gasLimit，是因为剩余的 gas会在交易完成后被返还（与购买时同样价格）到发送者账户。每个矿工自己选择他们想要接受和拒绝的gas价格。交易者们则需要在降低 gas 价格和使交易能尽快被矿工打包间进行权衡。\n geth安装 下载\n1  wget https://gethstore.blob.core.windows.net/builds/geth-alltools-linux-amd64-1.9.6-bd059680.tar.gz   解压缩\n1  tar zxvf https://gethstore.blob.core.windows.net/builds/geth-alltools-linux-amd64-1.9.6-bd059680.tar.gz   配置环境变量\n 文件夹改名 配置环境变量，检验方式which geth是否输出geth路径 编辑配置文件，保证下次仍可以找到该环境变量，检验方式如上  1 2 3  mv geth-alltools-linux-amd64-1.9.6-bd059680 ~/geth-home export PATH=$HOME/geth-home:$PATH echo `export PATH=$HOME/geth-home:$PATH` \u0026gt;\u0026gt; ~/.bashrc   NOTE:\n区块链开发最好用类unix系统，如ubuntu、Mac，否则可能不太稳定。如果是windows电脑可以选择用虚拟机或者双系统。\ngeth启动 1.在geth启动目录下创建文件genesis.json，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { \u0026#34;config\u0026#34;: { \u0026#34;chainId\u0026#34;: 18, \u0026#34;homesteadBlock\u0026#34;: 0, \u0026#34;eip150Block\u0026#34;: 0, \u0026#34;eip155Block\u0026#34;: 0, \u0026#34;eip158Block\u0026#34;: 0 }, \u0026#34;alloc\u0026#34; : {}, \u0026#34;coinbase\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000\u0026#34;, \u0026#34;difficulty\u0026#34; : \u0026#34;0x2\u0026#34;, \u0026#34;extraData\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;gasLimit\u0026#34; : \u0026#34;0xffffffff\u0026#34;, \u0026#34;nonce\u0026#34; : \u0026#34;0x0000000000000042\u0026#34;, \u0026#34;mixhash\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;parentHash\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;timestamp\u0026#34; : \u0026#34;0x00\u0026#34; }   步骤01：利用创世块文件初始化\n1  geth init genesis.json --datadir ./data   此时在data文件夹下生成了一些文件\n步骤02：启动geth节点\n1  geth --datadir ./data --networkid 18 --port 30303 --rpc --rpcport 8545 --rpcapi \u0026#39;db,net,eth,web3,personal\u0026#39; --rpccorsdomain \u0026#34;*\u0026#34; --gasprice 0 --allow-insecure-unlock console 2\u0026gt; 1.log   note:\n官方教程推荐使用clef工具进行账户管理，具体步骤可参见\n使用Web3.js与智能合约交互 以下示例web3.js版本为1.2\n现在假设你有一条运行中的区块链，且在区块链上部署了你的智能合约。\n步骤1 创建web3实例\n1 2 3  const Web3=require(\u0026#39;web3\u0026#39;); const web3=new Web3(Web3.HttpProvider(\u0026#39;http://localhost:7545\u0026#39;)); // 可以简写为 const web3=new Web3(\u0026#39;http://localhost:7545\u0026#39;);   所有与区块链的交互都返回一个Promsie，可以用await等待交互返回的结果，如下所示：\n1 2 3 4 5 6 7  async function run(){ const accounts=await web3.eth.getAccounts() console.log(accounts) const balance=await web3.eth.getBalance(accounts[0]) console.log(balance) } run();   步骤2 获取智能合约实例\n获取实例需要传入两个参数，合约地址以及合约ABI\nABI是智能合约可以被外部调用的JSON结构，即被external和public标注的函数。\r\n1  const MyContract=new web3.eth.Contract(abiJSON, contractAddress)   前面已经对Web3.js进行了简单的介绍，不再赘述。下面有几点需要了解：\n Web3.js的版本更新非常快，且版本间很可能不能兼容，所以本文中的例子很可能很快就无效了。 在以太坊的众多API中，有两个API最为重要eth_sendTransaction和eth_call。\n什么时候用transactions，什么时候用call呢？  在Solidity中有两种函数\n view函数，不会修改状态变量的函数 non-view函数，要修改状态变量的函数\n两种函数分别对应call和transactions，因此对应的代码如下：   call  // js const result=await myContract.methods.foo(1).call({from: '0x123ABC...'}) // solidity function foo(uint a) view external returns(bool){ // ... return true; } transaction  // js const result=await myContract.methods.bar(1).send({from: '0x123ABC...'}) // solidity function bar(uint a) external { // ... // no return } 参考教程 [1] 柏链公开课：第五期 Geth的安装\n[2] 讲师github：Geth安装与启动\n[3] Remix IDE官方文档\n[4] Solidity官方文档（该文档对区块链基础知识的描述写得很好）\n[5] 链门户：Geth介绍及如何运行以太坊节点\n[6] web3js官方文档\n[7] CSDN：学习以太坊Gas机制\n","description":"","id":4,"section":"posts","tags":["学术","区块链","智能合约"],"title":"区块链开发","uri":"https://moyahuang.github.io/zh/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/"},{"content":"Smart Contract ⚠️[truffle init]Error: Error making request to https://raw.githubusercontent.com\u0026hellip;\ndate: 2020/12/11\ndescription:\n√ Preparing to download\r× Downloading\rError: Error: Error: Error making request to https://raw.githubusercontent.com/truffle-box/bare-box/master/truffle-box.json. Got error: read ECONNRESET. Please check the format of the requested resource.\rat Object.unbox (C:\\Users\\w\\AppData\\Roaming\\npm\\node_modules\\truffle\\build\\webpack:\\packages\\truffle-box\\box.js:65:1)\rat processTicksAndRejections (internal/process/task_queues.js:97:5)\rTruffle v5.0.2 (core: 5.0.2)\rNode v12.18.3\rsolution: 修改hosts\n 打开C:\\windows\\system32\\drivers\\etc 在hosts文件中增加199.232.68.133 raw.githubusercontent.com  raw.githubusercontent.com的ip地址可以在以下或其他网站查询，没有则可以另外谷歌：\nhttps://www.ipaddress.com/\n⚠️[truffle develop]PSSecurityException\ndate: 2020/12/11\ndescription:\n息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。\r所在位置 行:1 字符: 1\r+ truffle develop\r+ ~~~~~~~\r+ CategoryInfo : SecurityError: (:) []，PSSecurityException\r+ FullyQualifiedErrorId : UnauthorizedAccess\rsolution: 更改开发者选项\n windows搜索并打开开发者设置 点击标签powershell的应用\n问题解决  ⚠️[remix] smart contract deploy error\ndate: 2020/12/18\ndescription:\ncreation of Judge errored: Error encoding arguments: Error: invalid BigNumber string (argument=\u0026quot;value\u0026quot;, value=\u0026quot;\u0026quot;, code=INVALID_ARGUMENT, version=bignumber/5.0.8)\rsolution: 应该在部署时传入构造函数的参数\nRemix IDE截图:\r\r\n⚠️ [web3.js] Invalid JSON RPC response: undefined\ndate: 2020/12/18\ndescription:\nError: Invalid JSON RPC response: undefined\rsolution: 网络不存在，检查HttpProvider参数url地址（Ganache创建的私有区块链端口为7545）\n[web3.js] BigNumber Error: new BigNumber() not a base 16 number\ndate: 2020/12/18\ndescription:\nBigNumber Error: new BigNumber() not a base 16 number: at raise (...\\node_modules\\bignumber.js\\bignumber.js)\rsolution:\n研究内容：访问控制通过确保授权用户对资源进行权限范围内的操作的一种技术手段，其目的在于实现数据开放的同时保证数据的安全和隐私性。计划基于以太坊智能合约设计并实现去中心化的访问控制机制，对其可行性、性能、隐私性等方面进行探索。\n关键词：访问控制，区块链，智能合约\n","description":"","id":5,"section":"posts","tags":["踩坑","开发"],"title":"走过的路都将成为财富之Debugging大合集","uri":"https://moyahuang.github.io/zh/posts/%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF%E9%83%BD%E5%B0%86%E6%88%90%E4%B8%BA%E8%B4%A2%E5%AF%8C%E4%B9%8Bdebugging%E5%A4%A7%E5%90%88%E9%9B%86/"},{"content":"// todo\n","description":"","id":6,"section":"posts","tags":["分类恐惧症"],"title":"技术合同登记","uri":"https://moyahuang.github.io/zh/posts/%E6%8A%80%E6%9C%AF%E5%90%88%E5%90%8C%E7%99%BB%E8%AE%B0/"},{"content":"偶尔画画的一些痕迹\n","description":"art gallery","id":7,"section":"gallery","tags":null,"title":"Art","uri":"https://moyahuang.github.io/zh/gallery/art/"},{"content":" Français\n\u0026ldquo;Il n\u0026rsquo;ya qu\u0026rsquo;un héroïsme au monde：c\u0026rsquo;est de voir le monde tel qu\u0026rsquo;il est et de l\u0026rsquo;aimer.\u0026quot;\nEnglish\n\u0026ldquo;There\u0026rsquo;s only one heroism in the world: to know the world as it is, and to love it.\u0026quot;\n中文\n“世上只有一种英雄主义，就是在看清生活真相之后仍然热爱生活。”\n\u0026ndash; Romain Rolland\n  “I just feel like women, they have minds, and they have souls, as well as just hearts. And they\u0026rsquo;ve got ambition, and they\u0026rsquo;ve got talent, as well as just beauty. I\u0026rsquo;m so sick of people saying that love is all a woman is fit for.”\nLittle Women\n ","description":"","id":8,"section":"posts","tags":["能量瓶"],"title":"那些话曾经给我力量","uri":"https://moyahuang.github.io/zh/posts/%E9%82%A3%E4%BA%9B%E8%AF%9D%E6%9B%BE%E7%BB%8F%E7%BB%99%E6%88%91%E5%8A%9B%E9%87%8F/"},{"content":"一则\n弦子曾经是央视《艺术人生》栏目的一名实习生。她在2018年7月写长文曝光了四年前被央视主持人朱军性骚扰自己的经历。我印象中看过这篇文章，内容记不太清楚了。2018年底，弦子把朱军告上法庭，决定诉诸法律维护自己的权力。终于，这个案子在昨天（2020年12月2日）开庭了。法院门口聚集了很多年轻人为她加油，给她鼓励。原来两年间，包括她在内的一个志愿者团队一直通过各种方式帮助受过性侵或者性骚扰的受害者。致敬温柔且勇敢的女性。\n弦子与她的朋友们:\r\r 二则\n早晨在郭家桥北街的煎饼果子店买煎饼果子。以前这个饼店只有中青年两个男人。今天突然多了一个中年女人，化着淡妆，看着很有气质，不时用山东味儿的口音和操着四川话路过的熟人说着只有他们才知道的话题。我厚着脸皮跟她多要了一片生菜。她不仅爽快地答应了，还特意给我在铁板上热了一下才包进去，说“女生要吃热乎些”。\n关于郭家桥北街\n郭家桥北街挨近川大南门，地图上看刚好是成都1.5环的位置，是一条有着独特韵味和温度的街道。面馆、奶茶店、菜市场、诊所、网吧、文具店、小卖部、花店\u0026hellip;自从放开路边摊经济之后，这里更加应有尽有了，糖葫芦、章鱼烧、蛋烘糕、家居、古玩、书摊、水果铺\u0026hellip;不管是清洁工大妈、外卖小哥、小店老板、公司职员还是学生、退休大爷大妈、大学教授都能在这里找到自己的位置。\n成都随处可见的卖鞋垫的奶奶:\r\r\n穿着黄色西装 梳着猫王发型的大爷:\r\r\n正经糖葫芦:\r\r\n早上喧哗的郭家桥北街:\r\r\n","description":"","id":9,"section":"posts","tags":["一缕阳光"],"title":"女性对女性的温柔小记\u0026关于郭家桥北街","uri":"https://moyahuang.github.io/zh/posts/%E5%A5%B3%E6%80%A7%E5%AF%B9%E5%A5%B3%E6%80%A7%E7%9A%84%E6%B8%A9%E6%9F%94%E5%B0%8F%E8%AE%B0%E5%85%B3%E4%BA%8E%E9%83%AD%E5%AE%B6%E6%A1%A5%E5%8C%97%E8%A1%97/"},{"content":"下文原名为《西南版权中心申请软著注意事项》，作者为Echo（非本人）。内容根据2020年10月15日至12月1日共6次现场办理软件著作权（预计要去7次）的材料出错细节，希望以后的软著申请办理可以引以为戒。\n西南版权中心申请软著注意事项 1. 前期注意事项 1）材料准备：营业执照复印件（加盖公章），预约人身份证复印件，申请表（加盖公章），源代码文件，说明书文件。\n2）检查系统与打印资料的对应情况：程序代码行数是否对应，编程语言，源文件是否上传错误，页眉与标题是否一致，图片copyright@写公司名字、截图不能侵犯版权，流水号是否一致。\n3）西南版权中心电话：028-87353161。\n2. 6次现场办理出错细节 1）共9份材料，其中4份过关，4份材料错误，1份未预约上。\n材料错误：程序代码行数不对应、页眉与标题不一致，图片copyright@没写公司名字、截图侵犯版权；工作人员发放补正通知书，需按要求修改材料后再次递交。\n未预约上：需要预约成功再去现场办理。\n2）共5份材料，都不过关，因为未预约。\n未预约：在预约界面上找不到项目，后来知道原因是系统上未按照补正意见修改并提交。\n3）共5份材料，其中1项过关，1项预约人错误，3份系统上未按补正意见修改并提交。\n预约人错误：需要修改预约人。\n系统上未按照补正意见修改并提交：有的源文件不对，代码量不对。\n4）共4份材料，其中1项过关，2项重复登记，1项程序语言写错。\n重复登记：已经登记的项目不能重复登记，应该使用以前登记的项目。\n语言写错：python写成java。\n5）共3份材料，其中2项过关，1项代码量未修改（办公电话一直打不通、未开权限）。\n6）共1份材料。预约12.7去办理，目测应该过关。\n2020.11.30\n软件著作权写作和申请还有很多小细节，但是时间和精力有限暂不加以补充。\n","description":"","id":10,"section":"posts","tags":["踩坑","软件著作权"],"title":"软件著作权申请实录","uri":"https://moyahuang.github.io/zh/posts/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%E7%94%B3%E8%AF%B7%E5%AE%9E%E5%BD%95/"},{"content":"温暖而又平凡的过往\n","description":"定格","id":11,"section":"gallery","tags":null,"title":"Photo","uri":"https://moyahuang.github.io/zh/gallery/photo/"},{"content":"本站为莫莫哒的博客2.0, 重建于2020年12月1日。创建目的在于记录自己的学习历程，整理自己的一些思考，以及保存一些需要公开访问路径的内容。莫莫哒本人认为无论是学习还是生活，都需要留下一些痕迹，且尝试过日记，手账，剪贴簿，手机自带备忘录，语音日记，日记软件，包括微博、豆瓣、微信等社交软件。未来也不排除在这里记录一些生活和兴趣爱好相关的内容。\nThis website is recreated in Dec. 1, 2020, for I personally like dark themes better these days. And I would like to give a thumbs up to the theme designer.\nI planned to migrate previous posts from Hexo-powered project to this brand new Hugo-powered project. But the migration task had been proven tedious and meaningless after I saved those pages to my Evernote.\nI hope this website would be long maintained by myself. For furter instruction on this theme, please refer to Hugo and 📝\n","description":"Moya Huang's personal website, Miao Huang, 黄苗, 四川大学, 四川师范大学, 前端","id":12,"section":"","tags":null,"title":"关于","uri":"https://moyahuang.github.io/zh/about/"},{"content":"概念 工业互联网 工业互联网是链接工业全系统、全产业链、全价值链，支撑工业智能化发展的关键基础设施，是新一代信息技术与制造业深度融合所形成的新兴业态和应用模式，是互联网从消费领域向生产领域、从虚拟经济向实体经济拓展的核心载体。\n虚拟经济 虚拟经济（Fictitious Economy）是相对实体经济而言的，是经济虚拟化（西方称之为“金融深化”Financial deepening）的必然产物。经济的本质是一套价值系统，包括物质价格系统和资产价格系统。与由成本和技术支撑定价的物质价格系统不同，资产价格系统是以资本化定价方式为基础的一套特定的价格体系，这也就是虚拟经济。由于资本化定价，人们的心理因素会对虚拟经济产生重要的影响；这也就是说，虚拟经济在运行上具有内在的波动性。广义地讲，虚拟经济除了目前研究较为集中的金融业、房地产业，还包括体育经济、博彩业、收藏业等，虚拟经济发展过度将会带来泡沫经济[2]。\n架构(architecture) vs. 模型(model) vs. 框架(framework) scheme schema model architecture framework\n参考文献 [1] 工业互联网是什么\n[2] “虚拟经济”百度百科词条\n","description":"","id":15,"section":"posts","tags":["分类恐惧症"],"title":"工业互联网小百科","uri":"https://moyahuang.github.io/zh/posts/%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"content":"冒泡排序 算法思想： 从数列第一个元素R1开始，与邻近元素R2进行比较，若R1\u0026gt;R2，则交换；同理，依次比较R2R3R4R5…，经过一趟比较，最大的数被交换到数列尾端。从数列第一个元素到数列倒数第二个元素，用内层循环表示。\n对除上述父数列的尾端元素的子数列重复上述操作。子数列尾端下标不断减小，用外层循环表示。\nJavaScript代码实现 1 2 3 4 5 6 7 8 9 10  function bubbleSort(nums){ for(var end=nums.length-1; end\u0026gt;0;end--){ for(var i=0; i\u0026lt;end;i++){ if(nums[i]\u0026gt;nums[i+1]){ [nums[i],nums[i+1]]=[nums[i+1],nums[i]]; } } } return nums; }   选择排序 算法思想： 在数列第一个元素依次开始遍历，找出最大的元素，与数列尾端元素交换。遍历元素，内层循环。\n对除上述父元素尾端元素的子数列，重复上述操作。尾端下表依次减小，外层循环。\nJavaScript代码实现 1 2 3 4 5 6 7 8 9 10 11 12  function selectSort(nums){ for(var end=nums.length-1; end\u0026gt;0;end--){ var maxPos=0; //这里注意要有等号 因为数列的最大值有可能本来就在尾端位置  for(var i=0;i\u0026lt;=end;i++){ if(nums[i]\u0026gt;nums[maxPos]){ maxPos=i; } } [nums[maxPos],nums[end]]=[nums[end],nums[maxPos]]; } }   直接插入排序 算法思想： 从最小有序子数列出发，依次将最小子数列邻近的数字插入该有序子数列中。\n元素个数只有1的数列出发，若该数列邻近元素小于该数列尾端元素，则依次从尾端元素往前查找合适的插入位置并插入。从尾端元素起向前遍历，内层循环。\n将该子数列长度加1，重复上述操作。尾端下标依次向后移动一位，外层循环。\nJavaScript代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13  function insertionSort(nums){ for(var end=1;end\u0026lt;nums.length;end++){ if(nums[end]\u0026lt;nums[end-1]){ var temp=nums[end]; var j; for(j=end-1;j\u0026gt;=0 \u0026amp;\u0026amp; nums[j]\u0026gt;temp; j--){ nums[j+1]=nums[j]; } nums[j]=temp; } } return nums; }   希尔排序 希尔排序是第一个突破算法复杂度O(n2)的算法，是直接插入排序的升级版。希尔排序是将固定间隔为某interval的元素看作一组数列，对该数列进行直接插入排序。\n算法思想： JavaScript代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function shellSort(nums){ var interval=Math.floor(nums.length/2) for(;interval\u0026gt;0;interval=Math.floor(interval/2)){ for(var end=interval; end\u0026lt;nums.length; end++){ if(nums[end]\u0026lt;nums[end-interval]){ var temp=nums[end]; var j; for(j=end-interval;j\u0026gt;=0\u0026amp;\u0026amp;nums[j]\u0026gt;temp;j-=interval){ nums[j+interval]=nums[j]; } nums[j]=temp; } } } return nums; }   快速排序 算法思想： 找一个基准数字，通过一趟排序，该基准数字的左边都比该数字小，右边都比该数字大。\n2020/12/1注：\n本文在迁移前，本来涉及LaTex数学公式。我尝试了很久想要使用Katex支持Latex，但是最终还是无法正确地使用$渲染LaTex。\n","description":"","id":16,"section":"posts","tags":["算法"],"title":"经典排序算法","uri":"https://moyahuang.github.io/zh/posts/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"content":"继承可以帮我们实现1. 代码重用 2. 以及进行规约？\nJS的对象采用原型继承(prototype-based inheritance)机制。当属性和方法添加到对象的原型上时，该对象及其后代便都会具备这些属性和方法。\n在其他诸如C语言等程序语言中，通常都有一个函数叫做构造函数(constructor)。构造函数就是为对象实例赋初值的。JS中没有类（ES6以前），普通函数(function)即可以用作构造函数，不过为了跟普通函数进行区分，一般会把用作构造函数的普通函数名首字母大写。\n当定义了这样一个函数（类）时\n当定义了这样一个函数（类）时\n1  function Crane(a, b){}   JS会为Crane.prototype增加一个属性constructor，其值指向刚才定义的方法（对象）或构造函数（以下统称为构造函数）本身，并且该构造函数还包括下面几个属性\n1  Crane.prototype={constructor: this}   用一张图可以表示为\n\n同时，构造函数本身也有constructor属性，这个属性指向Function构造函数\n\n注：ES6引入了关键词class，JS也可以像其他语言一样在class内部作用域定义构造函数。\n构造函数模式如何继承（下面的分类待斟酌，实质性区别是什么？） 使用Parent.call 上面提到的构造函数使用关键词new即可创建对象，这种模式怎样实现继承呢？我们看到下面的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function Bird(type, color){ this.type=type; this.color=color; this.fly=function(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is flying!\u0026#34;); } } //Parrot也是鸟 它有所有Bird拥有的属性 function Parrot(type, color){ Bird.call(this, type, color); //继承鸟的所有属性和方法  this.talk=function(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is talking!\u0026#34;) } } var prr=new Parrot(\u0026#34;鹦鹉\u0026#34;， \u0026#34;彩色de\u0026#34;); prr.talk(); prr.fly();   使用ES6的类关键词 ES6引入了类机制，使用关键词extends即可实现继承。上面的代码可以改成这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Bird{ constructor(type, color){ this.type=type; this.color=color; } fly(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is flying!\u0026#34;); } } class Parrot extends Bird{ constructor(type, color){ super(type, color); } talk(){ ... } }   伪类模式（不推荐） 我认为伪类模式与上面的继承方法的不同点在于，子类的构造函数会包含所有的属性，而无法不会进行属性的传递。因其关键点在于将子类的原型设置为父类对象。下面看一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var Mammal=function(name){ this.name=name; } //注意这里要采用加强prototype的方式添加方法 Mammal.prototype.get_name=function(){ return this.name; } Mammal.prototype.says=function(){ return this.saying||\u0026#39;\u0026#39;; } var Cat=function(name){ this.name=name; this.saying=\u0026#39;meow\u0026#39;; } Cat.prototype=new Mammal(); Cat.prototype.get_name=function(){ return this.says()+\u0026#39; \u0026#39;+this.name;//调用父类的方法 } var myCat=new Cat(\u0026#34;Katy\u0026#34;); console.log(myCat.get_name()); // \u0026#34;meow Katy\u0026#34;   当然，《JS语法精粹》里对上述的一些步骤进行了方法的封装，使程序表达性更高，隐藏了重复写prototype的一些”ugliness”。\n1 2 3 4 5  var Cat=function(name){ this.name=name; this.saying=\u0026#34;meow\u0026#34;; }.inherits(Mammal) .method(\u0026#34;get_name\u0026#34;,function(){...});   其中inherits是这么定义的\n1 2 3 4  Function.method(\u0026#34;inherits\u0026#34;,function(Parent){ this.prototype=new Parent(); return this; })   Function.method也是《JS语法精粹》定义的一个方法，常常用到，这里我写一遍算是复习了\n1 2 3 4 5 6  Function.prototype.method=function(name, func){ if(this.prototype[name]!==\u0026#34;function\u0026#34;){ this.prototype[name]=func; return this; } }   伪类模式的缺点： 原型模式 原型语言的好处是我们可以从一个原有的对象的基础上创建更多其他类似但又有所不同的对象，从而免除了将一个系统抽象类的过程。\n首先我们要做的就是创建一个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var myMammal={ name: \u0026#34;mammal\u0026#34;, get_name: function(){ return this.name; } says: function(){ return this.saying || \u0026#39;\u0026#39;; } } var myCat=Object.create(myMammal); myCat.name=\u0026#34;Siamese\u0026#34;; myCat.saying=\u0026#34;meow\u0026#34;; myCat.get_name=function(){ return this.says+\u0026#34; \u0026#34;+this.name; }   其中Object.create是《JS语言精粹》定义的一个方法，其作用是返回一个以参数对象为原型的新对象，下面来复习一遍\n1 2 3 4 5 6 7  if(typeof Object.create !== \u0026#39;function\u0026#39;){ Object.create=function(o){ var F=function(){}; F.prototype=o; return new F(); } }   上面的这种方式叫做差异化继承(differential inheritance)\n函数模式 上面所述的继承模式的缺点是，对象的所有属性和方法都暴露在外。采用函数模式可以克服上述缺点。\n首先我们要创建一个函数，用于生产新的对象。但是因为我们不需要用new来调用这个函数，所以该方法首字母小写。创建这个函数可以分为四个步骤：\n 创建一个新对象(任何方式都可以) 定义一些（私有的）变量和方法（在函数内部定义的变量和方法都是私有的，所以给私有加了括号） 为创建的新对象添加特权方法 返回新对象  这是书上的伪代码模板\n1 2 3 4 5 6 7  var constructor=function(spec, my){ var that, other private instance variables; my = my || {}; that = a new object; Add privileged methods to that return that; }   其中参数spec包含构造新实例的所有信息，而这个参数最好为本章节前提的object specifier，因为这样不用每次传入一个包含所有参数的完整对象。\n参数my是继承链上所有函数构造器共享的私有资源。（？是不是类似于保护类）\n下面继续用这种模式实现我们的示例，下面创建了一个父类对象\n1 2 3 4 5 6 7 8 9 10 11 12  var mammal=function(spec){ var that={};//创建新对象  that.get_name=function(){//为新对象添加特权方法  return spec.name; } that.says=function(){ return spec.saying || \u0026#39;\u0026#39;; } return that;//返回新对象 }; var myMamma=mammal({name: \u0026#39;mammal\u0026#39;});   其子类对象\n1 2 3 4 5 6 7 8  var cat=function(spec){ spec.saying=spec.saying||\u0026#39;\u0026#39;; var that=mammal(spec);//创建新对象  that.get_name=function(){//为新对象添加特权方法  return spec.says()+\u0026#39; \u0026#39;+spec.name; } return that; }   ❓ 书中定义的superior方法我不知道用来干嘛的\n组件？ 参考资料   https://www.freecodecamp.org/news/a-guide-to-prototype-based-class-inheritance-in-javascript-84953db26df0/\n  《JS语法精粹》\n  ","description":"","id":18,"section":"posts","tags":["前端","JavaScript"],"title":"JS的继承是个啥玩意儿","uri":"https://moyahuang.github.io/zh/posts/js%E7%9A%84%E7%BB%A7%E6%89%BF%E6%98%AF%E4%B8%AA%E5%95%A5%E7%8E%A9%E6%84%8F%E5%84%BF/"}]