[{"content":"一则\n弦子曾经是央视《艺术人生》栏目的一名实习生。她在2018年7月写长文曝光了四年前被央视主持人朱军性骚扰自己的经历。我印象中看过这篇文章，内容记不太清楚了。2018年底，弦子把朱军告上法庭，决定诉诸法律维护自己的权力。终于，这个案子在昨天（2020年12月2日）开庭了。法院门口聚集了很多年轻人为她加油，给她鼓励。原来两年间，包括她在内的一个志愿者团队一直通过各种方式帮助受过性侵或者性骚扰的受害者。致敬温柔且勇敢的女性。\n弦子与她的朋友们:\r\r 二则\n早晨在郭家桥北街的煎饼果子店买煎饼果子。以前这个饼店只有中青年两个男人。今天突然多了一个中年女人，化着淡妆，看着很有气质，不时用山东味儿的口音和操着四川话路过的熟人说着只有他们才知道的话题。我厚着脸皮跟她多要了一片生菜。她不仅爽快地答应了，还特意给我在铁板上热了一下才包进去，说“女生要吃热乎些”。\n关于郭家桥北街\n郭家桥北街挨近川大南门，地图上看刚好是成都1.5环的位置，是一条有着独特韵味和温度的街道。面馆、奶茶店、菜市场、诊所、网吧、文具店、小卖部、花店\u0026hellip;自从放开路边摊经济之后，这里更加应有尽有了，糖葫芦、章鱼烧、蛋烘糕、家居、古玩、书摊、水果铺\u0026hellip;不管是清洁工大妈、外卖小哥、小店老板、公司职员还是学生、退休大爷大妈、大学教授都能在这里找到自己的位置。\n成都随处可见的卖鞋垫的奶奶:\r\r\n穿着黄色西装 梳着猫王发型的大爷:\r\r\n正经糖葫芦:\r\r\n早上喧哗的郭家桥北街:\r\r\n","description":"","id":0,"section":"posts","tags":["一缕阳光"],"title":"女性对女性的温柔小记\u0026关于郭家桥北街","uri":"https://moyahuang.github.io/zh/posts/%E5%A5%B3%E6%80%A7%E5%AF%B9%E5%A5%B3%E6%80%A7%E7%9A%84%E6%B8%A9%E6%9F%94%E5%B0%8F%E8%AE%B0%E5%85%B3%E4%BA%8E%E9%83%AD%E5%AE%B6%E6%A1%A5%E5%8C%97%E8%A1%97/"},{"content":"下文原名为《西南版权中心申请软著注意事项》，作者为Echo（非本人）。内容根据2020年10月15日至12月1日共6次现场办理软件著作权（预计要去7次）的材料出错细节，希望以后的软著申请办理可以引以为戒。\n西南版权中心申请软著注意事项 1. 前期注意事项 1）材料准备：营业执照复印件（加盖公章），预约人身份证复印件，申请表（加盖公章），源代码文件，说明书文件。\n2）检查系统与打印资料的对应情况：程序代码行数是否对应，编程语言，源文件是否上传错误，页眉与标题是否一致，图片copyright@写公司名字、截图不能侵犯版权，流水号是否一致。\n3）西南版权中心电话：028-87353161。\n2. 6次现场办理出错细节 1）共9份材料，其中4份过关，4份材料错误，1份未预约上。\n材料错误：程序代码行数不对应、页眉与标题不一致，图片copyright@没写公司名字、截图侵犯版权；工作人员发放补正通知书，需按要求修改材料后再次递交。\n未预约上：需要预约成功再去现场办理。\n2）共5份材料，都不过关，因为未预约。\n未预约：在预约界面上找不到项目，后来知道原因是系统上未按照补正意见修改并提交。\n3）共5份材料，其中1项过关，1项预约人错误，3份系统上未按补正意见修改并提交。\n预约人错误：需要修改预约人。\n系统上未按照补正意见修改并提交：有的源文件不对，代码量不对。\n4）共4份材料，其中1项过关，2项重复登记，1项程序语言写错。\n重复登记：已经登记的项目不能重复登记，应该使用以前登记的项目。\n语言写错：python写成java。\n5）共3份材料，其中2项过关，1项代码量未修改（办公电话一直打不通、未开权限）。\n6）共1份材料。预约12.7去办理，目测应该过关。\n2020.11.30\n软件著作权写作和申请还有很多小细节，但是时间和精力有限暂不加以补充。\n","description":"","id":1,"section":"posts","tags":["踩坑","软件著作权"],"title":"软件著作权申请实录","uri":"https://moyahuang.github.io/zh/posts/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%E7%94%B3%E8%AF%B7%E5%AE%9E%E5%BD%95/"},{"content":"本站为莫莫哒的博客2.0, 重建于2020年12月1日。创建目的在于记录自己的学习历程，整理自己的一些思考，以及保存一些需要公开访问路径的内容。莫莫哒本人认为无论是学习还是生活，都需要留下一些痕迹，且尝试过日记，手账，剪贴簿，手机自带备忘录，语音日记，日记软件，包括微博、豆瓣、微信等社交软件。未来也不排除在这里记录一些生活和兴趣爱好相关的内容。\nThis website is recreated in Dec. 1, 2020, for I personally like dark themes better these days. And I would like to give a thumbs up to the theme designer.\nI planned to migrate previous posts from Hexo-powered project to this brand new Hugo-powered project. But the migration task had been proven tedious and meaningless after I saved those pages to my Evernote.\nI hope this website would be long maintained by myself. For furter instruction on this theme, please refer to Hugo and 📝\n","description":"Moya Huang's personal website, Miao Huang, 黄苗, 四川大学, 四川师范大学, 前端","id":2,"section":"","tags":null,"title":"关于","uri":"https://moyahuang.github.io/zh/about/"},{"content":"冒泡排序 算法思想： 从数列第一个元素R1开始，与邻近元素R2进行比较，若R1\u0026gt;R2，则交换；同理，依次比较R2R3R4R5…，经过一趟比较，最大的数被交换到数列尾端。从数列第一个元素到数列倒数第二个元素，用内层循环表示。\n对除上述父数列的尾端元素的子数列重复上述操作。子数列尾端下标不断减小，用外层循环表示。\nJavaScript代码实现 1 2 3 4 5 6 7 8 9 10  function bubbleSort(nums){ for(var end=nums.length-1; end\u0026gt;0;end--){ for(var i=0; i\u0026lt;end;i++){ if(nums[i]\u0026gt;nums[i+1]){ [nums[i],nums[i+1]]=[nums[i+1],nums[i]]; } } } return nums; }   选择排序 算法思想： 在数列第一个元素依次开始遍历，找出最大的元素，与数列尾端元素交换。遍历元素，内层循环。\n对除上述父元素尾端元素的子数列，重复上述操作。尾端下表依次减小，外层循环。\nJavaScript代码实现 1 2 3 4 5 6 7 8 9 10 11 12  function selectSort(nums){ for(var end=nums.length-1; end\u0026gt;0;end--){ var maxPos=0; //这里注意要有等号 因为数列的最大值有可能本来就在尾端位置  for(var i=0;i\u0026lt;=end;i++){ if(nums[i]\u0026gt;nums[maxPos]){ maxPos=i; } } [nums[maxPos],nums[end]]=[nums[end],nums[maxPos]]; } }   直接插入排序 算法思想： 从最小有序子数列出发，依次将最小子数列邻近的数字插入该有序子数列中。\n元素个数只有1的数列出发，若该数列邻近元素小于该数列尾端元素，则依次从尾端元素往前查找合适的插入位置并插入。从尾端元素起向前遍历，内层循环。\n将该子数列长度加1，重复上述操作。尾端下标依次向后移动一位，外层循环。\nJavaScript代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13  function insertionSort(nums){ for(var end=1;end\u0026lt;nums.length;end++){ if(nums[end]\u0026lt;nums[end-1]){ var temp=nums[end]; var j; for(j=end-1;j\u0026gt;=0 \u0026amp;\u0026amp; nums[j]\u0026gt;temp; j--){ nums[j+1]=nums[j]; } nums[j]=temp; } } return nums; }   希尔排序 希尔排序是第一个突破算法复杂度O(n2)的算法，是直接插入排序的升级版。希尔排序是将固定间隔为某interval的元素看作一组数列，对该数列进行直接插入排序。\n算法思想： JavaScript代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function shellSort(nums){ var interval=Math.floor(nums.length/2) for(;interval\u0026gt;0;interval=Math.floor(interval/2)){ for(var end=interval; end\u0026lt;nums.length; end++){ if(nums[end]\u0026lt;nums[end-interval]){ var temp=nums[end]; var j; for(j=end-interval;j\u0026gt;=0\u0026amp;\u0026amp;nums[j]\u0026gt;temp;j-=interval){ nums[j+interval]=nums[j]; } nums[j]=temp; } } } return nums; }   快速排序 算法思想： 找一个基准数字，通过一趟排序，该基准数字的左边都比该数字小，右边都比该数字大。\n2020/12/1注：\n本文在迁移前，本来涉及LaTex数学公式。我尝试了很久想要使用Katex支持Latex，但是最终还是无法正确地使用$渲染LaTex。\n","description":"","id":3,"section":"posts","tags":["算法"],"title":"经典排序算法","uri":"https://moyahuang.github.io/zh/posts/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"content":"继承可以帮我们实现1. 代码重用 2. 以及进行规约？\nJS的对象采用原型继承(prototype-based inheritance)机制。当属性和方法添加到对象的原型上时，该对象及其后代便都会具备这些属性和方法。\n在其他诸如C语言等程序语言中，通常都有一个函数叫做构造函数(constructor)。构造函数就是为对象实例赋初值的。JS中没有类（ES6以前），普通函数(function)即可以用作构造函数，不过为了跟普通函数进行区分，一般会把用作构造函数的普通函数名首字母大写。\n当定义了这样一个函数（类）时\n当定义了这样一个函数（类）时\n1  function Crane(a, b){}   JS会为Crane.prototype增加一个属性constructor，其值指向刚才定义的方法（对象）或构造函数（以下统称为构造函数）本身，并且该构造函数还包括下面几个属性\n1  Crane.prototype={constructor: this}   用一张图可以表示为\n\n同时，构造函数本身也有constructor属性，这个属性指向Function构造函数\n\n注：ES6引入了关键词class，JS也可以像其他语言一样在class内部作用域定义构造函数。\n构造函数模式如何继承（下面的分类待斟酌，实质性区别是什么？） 使用Parent.call 上面提到的构造函数使用关键词new即可创建对象，这种模式怎样实现继承呢？我们看到下面的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function Bird(type, color){ this.type=type; this.color=color; this.fly=function(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is flying!\u0026#34;); } } //Parrot也是鸟 它有所有Bird拥有的属性 function Parrot(type, color){ Bird.call(this, type, color); //继承鸟的所有属性和方法  this.talk=function(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is talking!\u0026#34;) } } var prr=new Parrot(\u0026#34;鹦鹉\u0026#34;， \u0026#34;彩色de\u0026#34;); prr.talk(); prr.fly();   使用ES6的类关键词 ES6引入了类机制，使用关键词extends即可实现继承。上面的代码可以改成这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Bird{ constructor(type, color){ this.type=type; this.color=color; } fly(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is flying!\u0026#34;); } } class Parrot extends Bird{ constructor(type, color){ super(type, color); } talk(){ ... } }   伪类模式（不推荐） 我认为伪类模式与上面的继承方法的不同点在于，子类的构造函数会包含所有的属性，而无法不会进行属性的传递。因其关键点在于将子类的原型设置为父类对象。下面看一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var Mammal=function(name){ this.name=name; } //注意这里要采用加强prototype的方式添加方法 Mammal.prototype.get_name=function(){ return this.name; } Mammal.prototype.says=function(){ return this.saying||\u0026#39;\u0026#39;; } var Cat=function(name){ this.name=name; this.saying=\u0026#39;meow\u0026#39;; } Cat.prototype=new Mammal(); Cat.prototype.get_name=function(){ return this.says()+\u0026#39; \u0026#39;+this.name;//调用父类的方法 } var myCat=new Cat(\u0026#34;Katy\u0026#34;); console.log(myCat.get_name()); // \u0026#34;meow Katy\u0026#34;   当然，《JS语法精粹》里对上述的一些步骤进行了方法的封装，使程序表达性更高，隐藏了重复写prototype的一些”ugliness”。\n1 2 3 4 5  var Cat=function(name){ this.name=name; this.saying=\u0026#34;meow\u0026#34;; }.inherits(Mammal) .method(\u0026#34;get_name\u0026#34;,function(){...});   其中inherits是这么定义的\n1 2 3 4  Function.method(\u0026#34;inherits\u0026#34;,function(Parent){ this.prototype=new Parent(); return this; })   Function.method也是《JS语法精粹》定义的一个方法，常常用到，这里我写一遍算是复习了\n1 2 3 4 5 6  Function.prototype.method=function(name, func){ if(this.prototype[name]!==\u0026#34;function\u0026#34;){ this.prototype[name]=func; return this; } }   伪类模式的缺点： 原型模式 原型语言的好处是我们可以从一个原有的对象的基础上创建更多其他类似但又有所不同的对象，从而免除了将一个系统抽象类的过程。\n首先我们要做的就是创建一个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var myMammal={ name: \u0026#34;mammal\u0026#34;, get_name: function(){ return this.name; } says: function(){ return this.saying || \u0026#39;\u0026#39;; } } var myCat=Object.create(myMammal); myCat.name=\u0026#34;Siamese\u0026#34;; myCat.saying=\u0026#34;meow\u0026#34;; myCat.get_name=function(){ return this.says+\u0026#34; \u0026#34;+this.name; }   其中Object.create是《JS语言精粹》定义的一个方法，其作用是返回一个以参数对象为原型的新对象，下面来复习一遍\n1 2 3 4 5 6 7  if(typeof Object.create !== \u0026#39;function\u0026#39;){ Object.create=function(o){ var F=function(){}; F.prototype=o; return new F(); } }   上面的这种方式叫做差异化继承(differential inheritance)\n函数模式 上面所述的继承模式的缺点是，对象的所有属性和方法都暴露在外。采用函数模式可以克服上述缺点。\n首先我们要创建一个函数，用于生产新的对象。但是因为我们不需要用new来调用这个函数，所以该方法首字母小写。创建这个函数可以分为四个步骤：\n 创建一个新对象(任何方式都可以) 定义一些（私有的）变量和方法（在函数内部定义的变量和方法都是私有的，所以给私有加了括号） 为创建的新对象添加特权方法 返回新对象  这是书上的伪代码模板\n1 2 3 4 5 6 7  var constructor=function(spec, my){ var that, other private instance variables; my = my || {}; that = a new object; Add privileged methods to that return that; }   其中参数spec包含构造新实例的所有信息，而这个参数最好为本章节前提的object specifier，因为这样不用每次传入一个包含所有参数的完整对象。\n参数my是继承链上所有函数构造器共享的私有资源。（？是不是类似于保护类）\n下面继续用这种模式实现我们的示例，下面创建了一个父类对象\n1 2 3 4 5 6 7 8 9 10 11 12  var mammal=function(spec){ var that={};//创建新对象  that.get_name=function(){//为新对象添加特权方法  return spec.name; } that.says=function(){ return spec.saying || \u0026#39;\u0026#39;; } return that;//返回新对象 }; var myMamma=mammal({name: \u0026#39;mammal\u0026#39;});   其子类对象\n1 2 3 4 5 6 7 8  var cat=function(spec){ spec.saying=spec.saying||\u0026#39;\u0026#39;; var that=mammal(spec);//创建新对象  that.get_name=function(){//为新对象添加特权方法  return spec.says()+\u0026#39; \u0026#39;+spec.name; } return that; }   ❓ 书中定义的superior方法我不知道用来干嘛的\n组件？ 参考资料   https://www.freecodecamp.org/news/a-guide-to-prototype-based-class-inheritance-in-javascript-84953db26df0/\n  《JS语法精粹》\n  ","description":"","id":4,"section":"posts","tags":["前端","JavaScript"],"title":"JS的继承是个啥玩意儿","uri":"https://moyahuang.github.io/zh/posts/js%E7%9A%84%E7%BB%A7%E6%89%BF%E6%98%AF%E4%B8%AA%E5%95%A5%E7%8E%A9%E6%84%8F%E5%84%BF/"}]