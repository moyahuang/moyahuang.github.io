[{"content":"STORROR是英国的一个专业跑酷团队，正式成立于2010年10月10日。成员包括两对兄弟在内分别是：人畜无害Max和辫子哥Benj Cave，平头哥Drew Taylor，红发Toby Segar，强悍Callum和小胖Sacha Powell，以及脏辫哥Josh Burnett-Blake。他们是跑酷运动员、作家、主播、摄像师\u0026hellip;\u0026hellip;迄今为止，已经在油管（youtube）上收获673万订阅，B站收获10.4万粉丝。他们有自己的服装品牌、网站、拍摄过跨越中日韩城市的跑酷纪录片，最近STORROR甚至开始与专业游戏开发团队合作开发他们的跑酷游戏《STORROR Parkour Pro》。\n\n喜欢STORROR的团队气氛，视频，视频配乐，还有他们的穿搭。通过他们的镜头能够发现奔跑的快乐，对人体机能的无限想象以及城市独特的美。\n关于跑酷 跑酷的动作可以分为四类：跳跃（vaults），落地（landings），栏杆（bar）和墙（wall）。\n跑酷（parkour） vs. 自由飞跃（free running）\nFreerunning是跑酷的分支，在跑酷动作中加入了更多空翻、旋转动作，更加注重动作的艺术性。但实际上跑酷和freeruning的定义非常模糊。\n 关于他们的穿搭 他们的穿搭配色几乎只有纯色黑白灰。穿搭单品都是运动类型，偏宽松，纯色加印字或logo。\n帽子  渔夫帽(bucket hat)   鸭舌帽(cap)   豆豆帽(beenie)   上身  T恤   圆领长袖(long sleeve)   兜帽卫衣（hoody）   下身  运动短裤（sweatshorts）   运动长裤(sweatpants)   袜子  运动长袜   鞋  运动鞋  ","description":"","id":0,"section":"posts","tags":null,"title":"男人这么美好的东西——跑酷团队STORROR","uri":"https://moyahuang.github.io/zh/posts/%E7%94%B7%E4%BA%BA%E8%BF%99%E4%B9%88%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%9C%E8%A5%BF%E8%B7%91%E9%85%B7%E5%9B%A2%E9%98%9Fstorror/"},{"content":"想让我的穿着体现我的内在和行事作风。\n我的衣橱     基本款 流行款     上衣 打底（✔条纹，高领）\n毛衣（V领，圆领，✔高领）\n卫衣（✔连帽，无帽）\n衬衫（纯色，✔条纹） 复古衬衫\n毛衣（✔毛衣背心、有花纹毛衣）   外套 风衣\n针织开衫\n大衣（✔H型大衣、茧型大衣）\n羽绒服\n西装（基础款、格纹款）\n✔牛仔外套 皮衣（皮西装、机车皮衣、✔皮外套）\n粗花呢外套\n超短外套   裙子 ✔格纹裙\n百褶裙\n连衣裙（印花款、纯色款） 纱裙\n皮裙   裤子 阔腿裤\n喇叭裤\n吸烟裤（黑色、格纹）\n铅笔裤（黑色、蓝色） 皮裤   配饰 彩色短袜 羊绒围巾 腰带 印花丝巾 帽子 珍珠配饰     参考小红书\r\r 基本穿搭准则  打造高腰线，显腿长  秋冬穿搭公式 叠穿配色原则\n① 浅深浅\n② 奥利奥（深浅深）\n③ 渐变色\n④ 同色系\n这些公式并不能涵盖全部的时尚风格。不过可以作为我时尚新手、的一个便于记忆的参考。\r ","description":"","id":1,"section":"posts","tags":["分类恐惧症"],"title":"穿搭笔记","uri":"https://moyahuang.github.io/zh/posts/%E7%A9%BF%E6%90%AD%E7%AC%94%E8%AE%B0/"},{"content":"在我众多弱点中最让我感觉到棘手的就是口语表达能力。即使是一个没有任何影响力的普通人，如果能够清晰精准甚至形象诙谐地表达自己的观点，描绘一个故事，多酷！高中以前生活的环境相对比较闭塞，在大学之后，越来越多的场合需要表达，遇见越来越多的人，越来越想要和另一个灵魂切磋打架。经验和科学可证，写作和说话可以激活大脑并帮助自己捋清思维，即使犯错，学会正确看待错误，能够形成一种正向循环。\n虽然理性来讲，无论是男女老少，都应该能给我们一些触动。但是不得不承认，作为一个女生，我更容易受到女性形象的影响，更容易让我产生一种“啊，我也想要”的冲动。下面列举一些我看着很有共鸣、很欢乐，或者印象很深的一些访谈。这些访谈中人物的表达能力（无关乎内容），让我“啊，我也想要这种能力”。\n 我上了大学之后，打算做一个学术女。至少年轻的时候，趁着自己的感情空白期，好好地用知识填补一下内心的空虚吧（笑）。 因为谈不了恋爱就只能做学术女，因为越是学术女就更谈不了恋爱，所以人生就构成了一个恶性循环。 我是身上种种厚厚的靠谱遮掩下还隐藏着一颗不靠谱而可爱的内心。 主持人：你是如何征婚的？答：我知道口风不严的一些人和一些大喇叭似的人，（向他们）说自己空窗，哭嚎自己今年一定要谈恋爱，透过他们向社会各界放出消息。一些和尚院系的老师已经和我接洽说希望我参加他们的联谊活动。 相亲变成了两个杰出青年（两个都是公众人物）就目前国际局势以及国家大事发表各自的看法。 我自己对人生的期待其实并不是有一群可以一起去逛街或者随叫随到的朋友。人生那么长，认识的人那么多，你的圈子那么大，但是驻守在你人生里的可能真的只有一小圈气场相投、莫失莫忘的朋友。我只要找到这么一小撮人就可以了。我不希望所有人都喜欢我，所有人都能跟我谈到一起去，我不期待这样的生活。 晚上睡觉之前躺在床上，心里连个念想都没有，唯一想到的就是也无风雨也无无晴，然后沉沉地睡去。真的连那种让你辗转反侧，心跳加速，夜不成眠的悸动都没有，然后就每天睡死过去。 我重新看我这一两年的记录，我发现仍然是观点大过生活，断语大过经历，没什么改观，仍然是一个生活的记录者和旁观者。 别人世界的一根火柴可以把我的世界烧个精光。 如果说我有超能力，可能是我的敏感和延伸的能力，可以把一件细节的事情延伸到无限长，挖掘到无限深。但与此对应的是生活的无能力。 成名过早（12岁成名）接踵而至的是各种各样的争议、打击和对你未来的预告。每一次应战你身上都会多一层盔甲。现在应战十年，你变成一个没有死穴，盔甲很重的人，这太可怕了。用文艺女青年的话来说，没有东西能够“击中你柔软的心房”，我觉得实在太不可爱了。  \r   我想要承担我以天下为己任的责任，我想为往圣继绝学，为万世开太平。我想要承担这些责任，所以才会抑郁。（但我庆幸自己）不是只是躺尸就觉得开心。 我最害怕的是别人期待我有多厉害。北大学生大部分都是正常人、凡人，我不了解的事情，我跟你的认知水平是一样的。你问我对什么事有什么意见，指望我很哇塞地给你很哇塞的答案，我希望大家不要这么认知我。 人的选择是非常有限的，社会是一个结构。人和社会是互构的，结构对人有限制，人对结构有改变。人陷在这个结构里只能这样选。 你问一个青年，你有什么目标。他可能没有什么目标，但就是压力好大好大。 现代人永远不满足，永远在进步，但永远不知道自己在往什么方向进步。 出路是跟不喜欢的东西做对抗，但对抗的姿态可能也不是一个持久的、自足的姿态。 人这个肉体的形态会受损，他有一个消亡过程。  \r  光看文字，这两段摘录其实大体都只是些中性的观点输出。但或是细微的语言、情绪，或是采访者的年龄，这两段访谈给我两种不同观感，前一段欢脱，后一段些微沉重。很多观点我都有共鸣，但同样的观点，我的表达可能不会那么生动，那么在点子上。因此，我希望我也可以自由地用语言表达自己，不让口拙限制自己的思维。\n好像“想太多”的人很容易变得不快乐，会给别人带来一些压力。我号称自己是人间观察者、表达者、思考者，其实不希望自己也陷入这种没来由的深沉。或许可以找到一种平衡点，深刻但快乐。\n","description":"","id":2,"section":"posts","tags":["杂谈"],"title":"我为什么对思想输出开始有了冲动","uri":"https://moyahuang.github.io/zh/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E6%80%9D%E6%83%B3%E8%BE%93%E5%87%BA%E5%BC%80%E5%A7%8B%E6%9C%89%E4%BA%86%E5%86%B2%E5%8A%A8/"},{"content":"Intro  Solidity   Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在以太坊虚拟机（EVM）上运行。\n  Remix   基于浏览器的 IDE，集成了编译器和 Solidity 运行时环境，不需要服务端组件。\n  MetaMask   MetaMask是通过浏览器访问分布式应用（dapps）的一个Chrome插件。可访问以太坊主网，任一以太坊测试网（Ropsten, Kovan, and Rinkeby），或者本地区块链。\n  Geth   Geth是Go Ethereum的缩写，是以太坊协议的三大原始实现之一（另外还有C++和Python），也是最受欢迎的客户端实现。它可以作为客户端运行在几乎任一操作系统上。安装了客户端的节点可以与其他节点建立p2p通信信道，签署和广播交易，挖掘，部署和与智能合约交互。\n启动Geth时，客户端会自动在端口8545启动RPC服务器。然后使用web3j等库连接到localhost：8545或使用curl或wget手动调用它来访问此端口的RPC服务器及其方法。\n  Web3.js   web.js是通过HTTP/IPC/WebSocket等协议用于和本地或远程以太坊节点进行交互的javascript库。\n  Quorum  简单的智能合约  Solidity第一行使用关键词pragma指定使用哪个版本编译器处理源代码。 event事件类型可以让监听该事件的listener收到通知，方便事务追踪。\n下面这个示例定义了一个事件，放在需要监听的函数最后执行：  1 2 3 4 5 6 7  event Sent(address from, address to, uint amount); function send(address receiver, uint amount) public { if (balances[msg.sender] \u0026lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); }   该事件可这样被监听:\n1 2 3 4 5 6 7 8 9 10  Coin.Sent().watch({}, \u0026#39;\u0026#39;, function(error, result) { if (!error) { console.log(\u0026#34;Coin transfer: \u0026#34; + result.args.amount + \u0026#34; coins were sent from \u0026#34; + result.args.from + \u0026#34; to \u0026#34; + result.args.to + \u0026#34;.\u0026#34;); console.log(\u0026#34;Balances now:\\n\u0026#34; + \u0026#34;Sender: \u0026#34; + Coin.balances.call(result.args.from) + \u0026#34;Receiver: \u0026#34; + Coin.balances.call(result.args.to)); } })   事件的参数可以通过上述回调函数的第二个参数的属性args访问，本例为result.args。\n3. 全局变量msg,tx,block保存一些区块链的属性，其中msg.sender永远指向访问当前函数的来源地址（在构造函数中，msg.sender指向智能合约的创建者）\n区块链基础 · 事务/交易(transaction)  区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。事务一词意味着你想做的（假设您想要同时更改两个值），要么一点没做，要么全部完成。此外，当你的事务被应用到数据库时，其他事务不能修改数据库。\n举个例子，设想一张表，列出电子货币中所有账户的余额。如果请求从一个账户转移到另一个账户，数据库的事务特性确保了如果从一个账户扣除金额，它总被添加到另一个账户。如果由于某些原因，无法添加金额到目标账户时，源账户也不会发生任何变化。\n此外，交易总是由发送人（创建者）签名。\n这样，就可非常简单地为数据库的特定修改增加访问保护机制。在电子货币的例子中，一个简单的检查可以确保只有持有账户密钥的人才能从中转账。\n 以太坊虚拟机 · 账号(account)  以太坊中有两类账户（它们共用同一个地址空间）： 外部账户(external accounts) 由公钥-私钥对（也就是人）控制； 合约账户(contract accounts) 由和账户一起存储的代码控制.\n外部账户的地址是由公钥决定的，而合约账户的地址是在创建该合约时确定的（这个地址通过合约创建者的地址和从该地址发出过的交易数量计算得到的，也就是所谓的“nonce”）\n无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。\n每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 存储(storage) 。\n此外，每个账户有一个以太币余额（ balance ）（最小单位是$Wei$, $1 ether=10^{18}Wei$），余额会因为发送包含以太币的交易而改变。\n · 交易(transaction)  交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。\n如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。\n如果目标账户是零账户（账户地址为 0 )，此交易将创建一个 新合约 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。\n · Gas  为了避免网络滥用及回避由于图灵完备而带来的一些不可避免的问题(the halting problem)，在以太坊中所有的程序执行都收费。Gas是基本的工作量成本单位，用于计量在以太坊区块链上执行操作所需的计算、存储资源和带宽，其目的是限制执行交易所需的工作量。各种操作的费用以gas为单位计算。任意的程序片段（包括合约创建、消息调用、分配资源以及访问账户storage、在虚拟机上执行操作等）都有一个普遍认同的gas成本。Gas有两个作用：\n 以太坊(不稳定的)价格和矿工工作报酬之间的缓冲 对拒绝服务(DoS)攻击的防御.  每一个交易都要指定一个 gas 上限：gasLimit。发送者通过在交易中指定gas price来购买gas，系统预先从发送者的账户余额中扣除gasLimit * gasPrice的交易费，即采用预付费机制。Gas price是指当你将交易发送到以太坊网络时，愿意支付的每单位gas的价格。如果账户余额不足，交易会被视为无效交易。之所以将其命名为 gasLimit，是因为剩余的 gas会在交易完成后被返还（与购买时同样价格）到发送者账户。每个矿工自己选择他们想要接受和拒绝的gas价格。交易者们则需要在降低 gas 价格和使交易能尽快被矿工打包间进行权衡。\n geth安装 下载\n1  wget https://gethstore.blob.core.windows.net/builds/geth-alltools-linux-amd64-1.9.6-bd059680.tar.gz   解压缩\n1  tar zxvf https://gethstore.blob.core.windows.net/builds/geth-alltools-linux-amd64-1.9.6-bd059680.tar.gz   配置环境变量\n 文件夹改名 配置环境变量，检验方式which geth是否输出geth路径 编辑配置文件，保证下次仍可以找到该环境变量，检验方式如上  1 2 3  mv geth-alltools-linux-amd64-1.9.6-bd059680 ~/geth-home export PATH=$HOME/geth-home:$PATH echo `export PATH=$HOME/geth-home:$PATH` \u0026gt;\u0026gt; ~/.bashrc   NOTE:\n区块链开发最好用类unix系统，如ubuntu、Mac，否则可能不太稳定。如果是windows电脑可以选择用虚拟机或者双系统。\ngeth启动 1.在geth启动目录下创建文件genesis.json，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { \u0026#34;config\u0026#34;: { \u0026#34;chainId\u0026#34;: 18, \u0026#34;homesteadBlock\u0026#34;: 0, \u0026#34;eip150Block\u0026#34;: 0, \u0026#34;eip155Block\u0026#34;: 0, \u0026#34;eip158Block\u0026#34;: 0 }, \u0026#34;alloc\u0026#34; : {}, \u0026#34;coinbase\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000\u0026#34;, \u0026#34;difficulty\u0026#34; : \u0026#34;0x2\u0026#34;, \u0026#34;extraData\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;gasLimit\u0026#34; : \u0026#34;0xffffffff\u0026#34;, \u0026#34;nonce\u0026#34; : \u0026#34;0x0000000000000042\u0026#34;, \u0026#34;mixhash\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;parentHash\u0026#34; : \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;timestamp\u0026#34; : \u0026#34;0x00\u0026#34; }   步骤01：利用创世块文件初始化\n1  geth init genesis.json --datadir ./data   此时在data文件夹下生成了一些文件\n步骤02：启动geth节点\n1  geth --datadir ./data --networkid 18 --port 30303 --rpc --rpcport 8545 --rpcapi \u0026#39;db,net,eth,web3,personal\u0026#39; --rpccorsdomain \u0026#34;*\u0026#34; --gasprice 0 --allow-insecure-unlock console 2\u0026gt; 1.log   note:\n官方教程推荐使用clef工具进行账户管理，具体步骤可参见\n使用Web3.js与智能合约交互 以下示例web3.js版本为1.2\n现在假设你有一条运行中的区块链，且在区块链上部署了你的智能合约。\n步骤1 创建web3实例\n1 2 3  const Web3=require(\u0026#39;web3\u0026#39;); const web3=new Web3(Web3.HttpProvider(\u0026#39;http://localhost:7545\u0026#39;)); // 可以简写为 const web3=new Web3(\u0026#39;http://localhost:7545\u0026#39;);   所有与区块链的交互都返回一个Promsie，可以用await等待交互返回的结果，如下所示：\n1 2 3 4 5 6 7  async function run(){ const accounts=await web3.eth.getAccounts() console.log(accounts) const balance=await web3.eth.getBalance(accounts[0]) console.log(balance) } run();   步骤2 获取智能合约实例\n获取实例需要传入两个参数，合约地址以及合约ABI\nABI是智能合约可以被外部调用的JSON结构，即被external和public标注的函数。\r\n1  const MyContract=new web3.eth.Contract(abiJSON, contractAddress)   前面已经对Web3.js进行了简单的介绍，不再赘述。下面有几点需要了解：\n Web3.js的版本更新非常快，且版本间很可能不能兼容，所以本文中的例子很可能很快就无效了。 在以太坊的众多API中，有两个API最为重要eth_sendTransaction和eth_call。\n什么时候用transactions，什么时候用call呢？  在Solidity中有两种函数\n view函数，不会修改状态变量的函数 non-view函数，要修改状态变量的函数\n两种函数分别对应call和transactions，因此对应的代码如下：   call  // js\rconst result=await myContract.methods.foo(1).call({from: '0x123ABC...'})\r// solidity\rfunction foo(uint a) view external returns(bool){\r// ...\rreturn true;\r}\rtransaction  // js\rconst result=await myContract.methods.bar(1).send({from: '0x123ABC...'})\r// solidity\rfunction bar(uint a) external {\r// ...\r// no return\r}\r参考教程 [1] 柏链公开课：第五期 Geth的安装\n[2] 讲师github：Geth安装与启动\n[3] Remix IDE官方文档\n[4] Solidity官方文档\n[4] Solidity官方文档（该文档对区块链基础知识的描述写得很好）\n[5] 链门户：Geth介绍及如何运行以太坊节点\n[5] web3js官方文档\n[6] web3js官方文档\n[7] CSDN：学习以太坊Gas机制\n","description":"","id":3,"section":"posts","tags":["学术","区块链","智能合约"],"title":"区块链开发","uri":"https://moyahuang.github.io/zh/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/"},{"content":"Smart Contract ⚠️[truffle init]Error: Error making request to https://raw.githubusercontent.com\u0026hellip;\ndate: 2020/12/11\ndescription:\n√ Preparing to download\r× Downloading\rError: Error: Error: Error making request to https://raw.githubusercontent.com/truffle-box/bare-box/master/truffle-box.json. Got error: read ECONNRESET. Please check the format of the requested resource.\rat Object.unbox (C:\\Users\\w\\AppData\\Roaming\\npm\\node_modules\\truffle\\build\\webpack:\\packages\\truffle-box\\box.js:65:1)\rat processTicksAndRejections (internal/process/task_queues.js:97:5)\rTruffle v5.0.2 (core: 5.0.2)\rNode v12.18.3\rsolution: 修改hosts\n 打开C:\\windows\\system32\\drivers\\etc 在hosts文件中增加199.232.68.133 raw.githubusercontent.com  raw.githubusercontent.com的ip地址可以在以下或其他网站查询，没有则可以另外谷歌：\nhttps://www.ipaddress.com/\n⚠️[truffle develop]PSSecurityException\ndate: 2020/12/11\ndescription:\n息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。\r所在位置 行:1 字符: 1\r+ truffle develop\r+ ~~~~~~~\r+ CategoryInfo : SecurityError: (:) []，PSSecurityException\r+ FullyQualifiedErrorId : UnauthorizedAccess\rsolution: 更改开发者选项\n windows搜索并打开开发者设置 点击标签powershell的应用\n问题解决  ⚠️[remix] smart contract deploy error\ndate: 2020/12/18\ndescription:\ncreation of Judge errored: Error encoding arguments: Error: invalid BigNumber string (argument=\u0026quot;value\u0026quot;, value=\u0026quot;\u0026quot;, code=INVALID_ARGUMENT, version=bignumber/5.0.8)\rsolution: 应该在部署时传入构造函数的参数\nRemix IDE截图\r\r\n⚠️ [web3.js] Invalid JSON RPC response: undefined\ndate: 2020/12/18\ndescription:\nError: Invalid JSON RPC response: undefined\rsolution: 网络不存在，检查HttpProvider参数url地址（Ganache创建的私有区块链端口为7545）\n[web3.js] BigNumber Error: new BigNumber() not a base 16 number\ndate: 2020/12/18\ndescription:\nBigNumber Error: new BigNumber() not a base 16 number: at raise (...\\node_modules\\bignumber.js\\bignumber.js)\rsolution:\n研究内容：访问控制通过确保授权用户对资源进行权限范围内的操作的一种技术手段，其目的在于实现数据开放的同时保证数据的安全和隐私性。计划基于以太坊智能合约设计并实现去中心化的访问控制机制，对其可行性、性能、隐私性等方面进行探索。\n关键词：访问控制，区块链，智能合约\n","description":"","id":4,"section":"posts","tags":["踩坑","开发"],"title":"走过的路都将成为财富之Debugging大合集","uri":"https://moyahuang.github.io/zh/posts/%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF%E9%83%BD%E5%B0%86%E6%88%90%E4%B8%BA%E8%B4%A2%E5%AF%8C%E4%B9%8Bdebugging%E5%A4%A7%E5%90%88%E9%9B%86/"},{"content":"// todo\n","description":"","id":5,"section":"posts","tags":["分类恐惧症"],"title":"技术合同登记","uri":"https://moyahuang.github.io/zh/posts/%E6%8A%80%E6%9C%AF%E5%90%88%E5%90%8C%E7%99%BB%E8%AE%B0/"},{"content":"偶尔画画的一些痕迹\n","description":"art gallery","id":6,"section":"gallery","tags":null,"title":"Art","uri":"https://moyahuang.github.io/zh/gallery/art/"},{"content":" Français\n\u0026ldquo;Il n\u0026rsquo;ya qu\u0026rsquo;un héroïsme au monde：c\u0026rsquo;est de voir le monde tel qu\u0026rsquo;il est et de l\u0026rsquo;aimer.\u0026quot;\nEnglish\n\u0026ldquo;There\u0026rsquo;s only one heroism in the world: to know the world as it is, and to love it.\u0026quot;\n中文\n“世上只有一种英雄主义，就是在看清生活真相之后仍然热爱生活。”\n\u0026ndash; Romain Rolland\n  “I just feel like women, they have minds, and they have souls, as well as just hearts. And they\u0026rsquo;ve got ambition, and they\u0026rsquo;ve got talent, as well as just beauty. I\u0026rsquo;m so sick of people saying that love is all a woman is fit for.”\nLittle Women\n ","description":"","id":7,"section":"posts","tags":["能量瓶"],"title":"那些话曾经给我力量","uri":"https://moyahuang.github.io/zh/posts/%E9%82%A3%E4%BA%9B%E8%AF%9D%E6%9B%BE%E7%BB%8F%E7%BB%99%E6%88%91%E5%8A%9B%E9%87%8F/"},{"content":"一则\n弦子曾经是央视《艺术人生》栏目的一名实习生。她在2018年7月写长文曝光了四年前被央视主持人朱军性骚扰自己的经历。我印象中看过这篇文章，内容记不太清楚了。2018年底，弦子把朱军告上法庭，决定诉诸法律维护自己的权力。终于，这个案子在昨天（2020年12月2日）开庭了。法院门口聚集了很多年轻人为她加油，给她鼓励。原来两年间，包括她在内的一个志愿者团队一直通过各种方式帮助受过性侵或者性骚扰的受害者。致敬温柔且勇敢的女性。\n\r弦子与她的朋友们\r\r\r二则\n早晨在郭家桥北街的煎饼果子店买煎饼果子。以前这个饼店只有中青年两个男人。今天突然多了一个中年女人，化着淡妆，看着很有气质，不时用山东味儿的口音和操着四川话路过的熟人说着只有他们才知道的话题。我厚着脸皮跟她多要了一片生菜。她不仅爽快地答应了，还特意给我在铁板上热了一下才包进去，说“女生要吃热乎些”。\n关于郭家桥北街\n郭家桥北街挨近川大南门，地图上看刚好是成都1.5环的位置，是一条有着独特韵味和温度的街道。面馆、奶茶店、菜市场、诊所、网吧、文具店、小卖部、花店\u0026hellip;自从放开路边摊经济之后，这里更加应有尽有了，糖葫芦、章鱼烧、蛋烘糕、家居、古玩、书摊、水果铺\u0026hellip;不管是清洁工大妈、外卖小哥、小店老板、公司职员还是学生、退休大爷大妈、大学教授都能在这里找到自己的位置。\n\r成都随处可见的卖鞋垫的奶奶\r\r\r穿着黄色西装 梳着猫王发型的大爷\r\r\r正经糖葫芦\r\r\r早上喧哗的郭家桥北街\r\r\r","description":"","id":8,"section":"posts","tags":["一缕阳光"],"title":"女性对女性的温柔小记\u0026关于郭家桥北街","uri":"https://moyahuang.github.io/zh/posts/%E5%A5%B3%E6%80%A7%E5%AF%B9%E5%A5%B3%E6%80%A7%E7%9A%84%E6%B8%A9%E6%9F%94%E5%B0%8F%E8%AE%B0%E5%85%B3%E4%BA%8E%E9%83%AD%E5%AE%B6%E6%A1%A5%E5%8C%97%E8%A1%97/"},{"content":"下文原名为《西南版权中心申请软著注意事项》，作者为Echo（非本人）。内容根据2020年10月15日至12月1日共6次现场办理软件著作权（预计要去7次）的材料出错细节，希望以后的软著申请办理可以引以为戒。\n西南版权中心申请软著注意事项 1. 前期注意事项 1）材料准备：营业执照复印件（加盖公章），预约人身份证复印件，申请表（加盖公章），源代码文件，说明书文件。\n2）检查系统与打印资料的对应情况：程序代码行数是否对应，编程语言，源文件是否上传错误，页眉与标题是否一致，图片copyright@写公司名字、截图不能侵犯版权，流水号是否一致。\n3）西南版权中心电话：028-87353161。\n2. 6次现场办理出错细节 1）共9份材料，其中4份过关，4份材料错误，1份未预约上。\n材料错误：程序代码行数不对应、页眉与标题不一致，图片copyright@没写公司名字、截图侵犯版权；工作人员发放补正通知书，需按要求修改材料后再次递交。\n未预约上：需要预约成功再去现场办理。\n2）共5份材料，都不过关，因为未预约。\n未预约：在预约界面上找不到项目，后来知道原因是系统上未按照补正意见修改并提交。\n3）共5份材料，其中1项过关，1项预约人错误，3份系统上未按补正意见修改并提交。\n预约人错误：需要修改预约人。\n系统上未按照补正意见修改并提交：有的源文件不对，代码量不对。\n4）共4份材料，其中1项过关，2项重复登记，1项程序语言写错。\n重复登记：已经登记的项目不能重复登记，应该使用以前登记的项目。\n语言写错：python写成java。\n5）共3份材料，其中2项过关，1项代码量未修改（办公电话一直打不通、未开权限）。\n6）共1份材料。预约12.7去办理，目测应该过关。\n2020.11.30\n软件著作权写作和申请还有很多小细节，但是时间和精力有限暂不加以补充。\n","description":"","id":9,"section":"posts","tags":["踩坑","软件著作权"],"title":"软件著作权申请实录","uri":"https://moyahuang.github.io/zh/posts/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%E7%94%B3%E8%AF%B7%E5%AE%9E%E5%BD%95/"},{"content":"温暖而又平凡的过往\n","description":"定格","id":10,"section":"gallery","tags":null,"title":"Photo","uri":"https://moyahuang.github.io/zh/gallery/photo/"},{"content":"本站为莫莫哒的博客2.0, 重建于2020年12月1日。创建目的在于记录自己的学习历程，整理自己的一些思考，以及保存一些需要公开访问路径的内容。莫莫哒本人认为无论是学习还是生活，都需要留下一些痕迹，且尝试过日记，手账，剪贴簿，手机自带备忘录，语音日记，日记软件，包括微博、豆瓣、微信等社交软件。未来也不排除在这里记录一些生活和兴趣爱好相关的内容。\n可能有一天我会发现我以前的博客写得像💩一样，或者本人过往的思维方式特别怪异，但如果不开始，那么永远都不会有进步。\nThis website is recreated in Dec. 1, 2020, for I personally like dark themes better these days. And I would like to give a thumbs up to the theme designer.\nI planned to migrate previous posts from Hexo-powered project to this brand new Hugo-powered project. But the migration task had been proven tedious and meaningless after I saved those pages to my Evernote.\nI hope this website would be long maintained by myself. For furter instruction on this theme, please refer to Hugo and 📝\n","description":"Moya Huang's personal website, Miao Huang, 黄苗, 四川大学, 四川师范大学, 前端","id":11,"section":"","tags":null,"title":"关于","uri":"https://moyahuang.github.io/zh/about/"},{"content":"概念 工业互联网 工业互联网是链接工业全系统、全产业链、全价值链，支撑工业智能化发展的关键基础设施，是新一代信息技术与制造业深度融合所形成的新兴业态和应用模式，是互联网从消费领域向生产领域、从虚拟经济向实体经济拓展的核心载体。\n虚拟经济 虚拟经济（Fictitious Economy）是相对实体经济而言的，是经济虚拟化（西方称之为“金融深化”Financial deepening）的必然产物。经济的本质是一套价值系统，包括物质价格系统和资产价格系统。与由成本和技术支撑定价的物质价格系统不同，资产价格系统是以资本化定价方式为基础的一套特定的价格体系，这也就是虚拟经济。由于资本化定价，人们的心理因素会对虚拟经济产生重要的影响；这也就是说，虚拟经济在运行上具有内在的波动性。广义地讲，虚拟经济除了目前研究较为集中的金融业、房地产业，还包括体育经济、博彩业、收藏业等，虚拟经济发展过度将会带来泡沫经济[2]。\n架构(architecture) vs. 模型(model) vs. 框架(framework) scheme schema model architecture framework\n参考文献 [1] 工业互联网是什么\n[2] “虚拟经济”百度百科词条\n","description":"","id":14,"section":"posts","tags":["分类恐惧症"],"title":"工业互联网小百科","uri":"https://moyahuang.github.io/zh/posts/%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"content":"冒泡排序 算法思想： 从数列第一个元素R1开始，与邻近元素R2进行比较，若R1\u0026gt;R2，则交换；同理，依次比较R2R3R4R5…，经过一趟比较，最大的数被交换到数列尾端。从数列第一个元素到数列倒数第二个元素，用内层循环表示。\n对除上述父数列的尾端元素的子数列重复上述操作。子数列尾端下标不断减小，用外层循环表示。\nJavaScript代码实现 1 2 3 4 5 6 7 8 9 10  function bubbleSort(nums){ for(var end=nums.length-1; end\u0026gt;0;end--){ for(var i=0; i\u0026lt;end;i++){ if(nums[i]\u0026gt;nums[i+1]){ [nums[i],nums[i+1]]=[nums[i+1],nums[i]]; } } } return nums; }   选择排序 算法思想： 在数列第一个元素依次开始遍历，找出最大的元素，与数列尾端元素交换。遍历元素，内层循环。\n对除上述父元素尾端元素的子数列，重复上述操作。尾端下表依次减小，外层循环。\nJavaScript代码实现 1 2 3 4 5 6 7 8 9 10 11 12  function selectSort(nums){ for(var end=nums.length-1; end\u0026gt;0;end--){ var maxPos=0; //这里注意要有等号 因为数列的最大值有可能本来就在尾端位置  for(var i=0;i\u0026lt;=end;i++){ if(nums[i]\u0026gt;nums[maxPos]){ maxPos=i; } } [nums[maxPos],nums[end]]=[nums[end],nums[maxPos]]; } }   直接插入排序 算法思想： 从最小有序子数列出发，依次将最小子数列邻近的数字插入该有序子数列中。\n元素个数只有1的数列出发，若该数列邻近元素小于该数列尾端元素，则依次从尾端元素往前查找合适的插入位置并插入。从尾端元素起向前遍历，内层循环。\n将该子数列长度加1，重复上述操作。尾端下标依次向后移动一位，外层循环。\nJavaScript代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13  function insertionSort(nums){ for(var end=1;end\u0026lt;nums.length;end++){ if(nums[end]\u0026lt;nums[end-1]){ var temp=nums[end]; var j; for(j=end-1;j\u0026gt;=0 \u0026amp;\u0026amp; nums[j]\u0026gt;temp; j--){ nums[j+1]=nums[j]; } nums[j]=temp; } } return nums; }   希尔排序 希尔排序是第一个突破算法复杂度O(n2)的算法，是直接插入排序的升级版。希尔排序是将固定间隔为某interval的元素看作一组数列，对该数列进行直接插入排序。\n算法思想： JavaScript代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function shellSort(nums){ var interval=Math.floor(nums.length/2) for(;interval\u0026gt;0;interval=Math.floor(interval/2)){ for(var end=interval; end\u0026lt;nums.length; end++){ if(nums[end]\u0026lt;nums[end-interval]){ var temp=nums[end]; var j; for(j=end-interval;j\u0026gt;=0\u0026amp;\u0026amp;nums[j]\u0026gt;temp;j-=interval){ nums[j+interval]=nums[j]; } nums[j]=temp; } } } return nums; }   快速排序 算法思想： 找一个基准数字，通过一趟排序，该基准数字的左边都比该数字小，右边都比该数字大。\n2020/12/1注：\n本文在迁移前，本来涉及LaTex数学公式。我尝试了很久想要使用Katex支持Latex，但是最终还是无法正确地使用$渲染LaTex。\n","description":"","id":15,"section":"posts","tags":["算法"],"title":"经典排序算法","uri":"https://moyahuang.github.io/zh/posts/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"content":"继承可以帮我们实现1. 代码重用 2. 以及进行规约？\nJS的对象采用原型继承(prototype-based inheritance)机制。当属性和方法添加到对象的原型上时，该对象及其后代便都会具备这些属性和方法。\n在其他诸如C语言等程序语言中，通常都有一个函数叫做构造函数(constructor)。构造函数就是为对象实例赋初值的。JS中没有类（ES6以前），普通函数(function)即可以用作构造函数，不过为了跟普通函数进行区分，一般会把用作构造函数的普通函数名首字母大写。\n当定义了这样一个函数（类）时\n当定义了这样一个函数（类）时\n1  function Crane(a, b){}   JS会为Crane.prototype增加一个属性constructor，其值指向刚才定义的方法（对象）或构造函数（以下统称为构造函数）本身，并且该构造函数还包括下面几个属性\n1  Crane.prototype={constructor: this}   用一张图可以表示为\n\n同时，构造函数本身也有constructor属性，这个属性指向Function构造函数\n\n注：ES6引入了关键词class，JS也可以像其他语言一样在class内部作用域定义构造函数。\n构造函数模式如何继承（下面的分类待斟酌，实质性区别是什么？） 使用Parent.call 上面提到的构造函数使用关键词new即可创建对象，这种模式怎样实现继承呢？我们看到下面的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function Bird(type, color){ this.type=type; this.color=color; this.fly=function(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is flying!\u0026#34;); } } //Parrot也是鸟 它有所有Bird拥有的属性 function Parrot(type, color){ Bird.call(this, type, color); //继承鸟的所有属性和方法  this.talk=function(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is talking!\u0026#34;) } } var prr=new Parrot(\u0026#34;鹦鹉\u0026#34;， \u0026#34;彩色de\u0026#34;); prr.talk(); prr.fly();   使用ES6的类关键词 ES6引入了类机制，使用关键词extends即可实现继承。上面的代码可以改成这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Bird{ constructor(type, color){ this.type=type; this.color=color; } fly(){ console.log(this.color+\u0026#39; \u0026#39;+this.type+\u0026#34; is flying!\u0026#34;); } } class Parrot extends Bird{ constructor(type, color){ super(type, color); } talk(){ ... } }   伪类模式（不推荐） 我认为伪类模式与上面的继承方法的不同点在于，子类的构造函数会包含所有的属性，而无法不会进行属性的传递。因其关键点在于将子类的原型设置为父类对象。下面看一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var Mammal=function(name){ this.name=name; } //注意这里要采用加强prototype的方式添加方法 Mammal.prototype.get_name=function(){ return this.name; } Mammal.prototype.says=function(){ return this.saying||\u0026#39;\u0026#39;; } var Cat=function(name){ this.name=name; this.saying=\u0026#39;meow\u0026#39;; } Cat.prototype=new Mammal(); Cat.prototype.get_name=function(){ return this.says()+\u0026#39; \u0026#39;+this.name;//调用父类的方法 } var myCat=new Cat(\u0026#34;Katy\u0026#34;); console.log(myCat.get_name()); // \u0026#34;meow Katy\u0026#34;   当然，《JS语法精粹》里对上述的一些步骤进行了方法的封装，使程序表达性更高，隐藏了重复写prototype的一些”ugliness”。\n1 2 3 4 5  var Cat=function(name){ this.name=name; this.saying=\u0026#34;meow\u0026#34;; }.inherits(Mammal) .method(\u0026#34;get_name\u0026#34;,function(){...});   其中inherits是这么定义的\n1 2 3 4  Function.method(\u0026#34;inherits\u0026#34;,function(Parent){ this.prototype=new Parent(); return this; })   Function.method也是《JS语法精粹》定义的一个方法，常常用到，这里我写一遍算是复习了\n1 2 3 4 5 6  Function.prototype.method=function(name, func){ if(this.prototype[name]!==\u0026#34;function\u0026#34;){ this.prototype[name]=func; return this; } }   伪类模式的缺点： 原型模式 原型语言的好处是我们可以从一个原有的对象的基础上创建更多其他类似但又有所不同的对象，从而免除了将一个系统抽象类的过程。\n首先我们要做的就是创建一个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var myMammal={ name: \u0026#34;mammal\u0026#34;, get_name: function(){ return this.name; } says: function(){ return this.saying || \u0026#39;\u0026#39;; } } var myCat=Object.create(myMammal); myCat.name=\u0026#34;Siamese\u0026#34;; myCat.saying=\u0026#34;meow\u0026#34;; myCat.get_name=function(){ return this.says+\u0026#34; \u0026#34;+this.name; }   其中Object.create是《JS语言精粹》定义的一个方法，其作用是返回一个以参数对象为原型的新对象，下面来复习一遍\n1 2 3 4 5 6 7  if(typeof Object.create !== \u0026#39;function\u0026#39;){ Object.create=function(o){ var F=function(){}; F.prototype=o; return new F(); } }   上面的这种方式叫做差异化继承(differential inheritance)\n函数模式 上面所述的继承模式的缺点是，对象的所有属性和方法都暴露在外。采用函数模式可以克服上述缺点。\n首先我们要创建一个函数，用于生产新的对象。但是因为我们不需要用new来调用这个函数，所以该方法首字母小写。创建这个函数可以分为四个步骤：\n 创建一个新对象(任何方式都可以) 定义一些（私有的）变量和方法（在函数内部定义的变量和方法都是私有的，所以给私有加了括号） 为创建的新对象添加特权方法 返回新对象  这是书上的伪代码模板\n1 2 3 4 5 6 7  var constructor=function(spec, my){ var that, other private instance variables; my = my || {}; that = a new object; Add privileged methods to that return that; }   其中参数spec包含构造新实例的所有信息，而这个参数最好为本章节前提的object specifier，因为这样不用每次传入一个包含所有参数的完整对象。\n参数my是继承链上所有函数构造器共享的私有资源。（？是不是类似于保护类）\n下面继续用这种模式实现我们的示例，下面创建了一个父类对象\n1 2 3 4 5 6 7 8 9 10 11 12  var mammal=function(spec){ var that={};//创建新对象  that.get_name=function(){//为新对象添加特权方法  return spec.name; } that.says=function(){ return spec.saying || \u0026#39;\u0026#39;; } return that;//返回新对象 }; var myMamma=mammal({name: \u0026#39;mammal\u0026#39;});   其子类对象\n1 2 3 4 5 6 7 8  var cat=function(spec){ spec.saying=spec.saying||\u0026#39;\u0026#39;; var that=mammal(spec);//创建新对象  that.get_name=function(){//为新对象添加特权方法  return spec.says()+\u0026#39; \u0026#39;+spec.name; } return that; }   ❓ 书中定义的superior方法我不知道用来干嘛的\n组件？ 参考资料   https://www.freecodecamp.org/news/a-guide-to-prototype-based-class-inheritance-in-javascript-84953db26df0/\n  《JS语法精粹》\n  ","description":"","id":17,"section":"posts","tags":["前端","JavaScript"],"title":"JS的继承是个啥玩意儿","uri":"https://moyahuang.github.io/zh/posts/js%E7%9A%84%E7%BB%A7%E6%89%BF%E6%98%AF%E4%B8%AA%E5%95%A5%E7%8E%A9%E6%84%8F%E5%84%BF/"}]